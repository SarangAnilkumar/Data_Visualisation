<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Premier League Tactics & Transfers: A Data-Driven Exploration</title>

    <!-- Libraries: D3.js, D3 Sankey, Bootstrap -->
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://unpkg.com/d3-sankey@0.12.3/dist/d3-sankey.min.js"></script>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
     
    <!-- Intro.js Library for Guided Tour -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/intro.js/7.0.1/introjs.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/intro.js/7.0.1/intro.min.js"></script>
    

    
    <!-- Styles: Tooltip, Dropdown, Chart-Specific Styles -->
    <style>
        /* General Layout and Common Styles */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            color: #333;
        }
    
        h1,
        h2 {
            text-align: center;
            color: #444;
            margin-bottom: 20px;
        }

        h4 {
            color: yellowgreen;
            font-size: 14px;
        }

        .introjs-tooltip {
            background-color: #333;
            color: #fff;
            font-size: 14px;
            border-radius: 8px;
        }
    
        /* Intro.js Tooltip Buttons */
        .introjs-button {
            background-color: #007bff; /* Button background color */
            color: #fff; /* Button text color */
            border: none;
            padding: 8px 12px;
            font-size: 13px;
            border-radius: 4px;
            transition: background-color 0.3s ease;
        }

        .introjs-button:hover {
            background-color: #0056b3; /* Darker blue on hover */
        }

        /* Customizing the "Skip Tour" Button */
        .introjs-skipbutton {
            background-color: transparent; /* Transparent background */
            color: #007bff; 
            font-weight: bold;
            border: none;
            font-size: 13px;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .introjs-skipbutton:hover {
            color: #0056b3; 
            text-decoration: underline; 
        }

        /* Styling the Done Button */
        .introjs-donebutton {
            background-color: #28a745; 
            color: #fff;
            border: none;
            padding: 8px 12px;
            font-size: 13px;
            border-radius: 4px;
        }

        .introjs-donebutton:hover {
            background-color: #218838; 
        }

        /* Tooltip Styles */
        .tooltip {
            position: absolute;
            padding: 8px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
    
        /* Dropdown Styles */
        .dropdown-multiselect {
            width: 200px;
            display: inline-block;
            border: 1px solid #007bff;
            border-radius: 4px;
            padding: 8px;
            cursor: pointer;
            position: relative;
            background-color: #f8f9fa;
            margin: 10px;
        }

        .dropdown-multiselect .dropbtn {
            width: 100%;
            padding: 8px;
            text-align: left;
            background-color: #f8f9fa;
            border: 1px solid #ccc;
            cursor: pointer;
            border-radius: 4px;
        }

        .dropdown-multiselect .dropdown-multiselect-content {
            display: none;
            position: absolute;
            background-color: #f8f9fa;
            min-width: 100%;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
            max-height: 200px;
            border: 1px solid #ccc;
        }

        .dropdown-multiselect .dropdown-multiselect-content.show {
            display: block;
        }
    
        .dropdown-multiselect.active .dropdown-multiselect-content {
            display: block;
        }
    
        .dropdown-multiselect-content {
            display: none;
            position: absolute;
            background-color: #f8f9fa;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            max-height: 200px;
            overflow-y: auto; 
            width: 100%;
            border: 1px solid #007bff;
            border-radius: 4px;
            padding: 5px 0;
            z-index: 1000;
        }
    
        .dropdown-multiselect-content label {
            display: block;
            padding: 8px;
            font-size: 14px;
            cursor: pointer;
            color: #333;
        }
    
        .dropdown-multiselect-content label:hover {
            background-color: #e2e6ea;
        }
    
        .hidden {
            display: none;
        }
    
        /* Bar Chart Styles */
        #bar-chart-svg rect {
            fill: #009E73;
            opacity: 0.85;
            transition: fill 0.3s, filter 0.3s;
        }
    
        #bar-chart-svg rect:hover {
            fill: #cad82f;
            filter: drop-shadow(0 0 15px#d4ff00);
        }

        .bar-chart-click-tooltip {
            position: absolute;
            padding: 10px;
            background: white;
            color: #333;
            border: 1px solid #ccc;
            border-radius: 8px;
            font-size: 14px;
            pointer-events: auto;
            opacity: 0;
            transition: opacity 0.3s, transform 0.3s;
            max-width: 300px;
            z-index: 10;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        .bar-chart-click-tooltip.show {
            opacity: 1;
            transform: translateY(0);
        }

        .bar-chart-click-tooltip.hide {
            opacity: 0;
            transform: translateY(20px);
        }

        .bar-chart-click-tooltip table {
            width: 100%;
            border-collapse: collapse;
        }

        .bar-chart-click-tooltip td {
            padding: 4px 8px;
            border-bottom: 1px solid #ccc;
        }

        .bar-chart-click-tooltip tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        .bar-chart-click-tooltip tr:hover {
            background-color: #f1f1f1;
        }

        .bar-chart-click-tooltip strong {
            font-weight: bold;
        }

        .bar-chart-click-tooltip::-webkit-scrollbar {
            width: 8px;
        }

        .bar-chart-click-tooltip::-webkit-scrollbar-thumb {
            background-color: #ccc;
            border-radius: 4px;
        }

        .bar-chart-click-tooltip div {
            max-height: 200px;
            overflow-y: auto;
        }

        #chart-container {
            position: relative;
        }

        #winGraph {
            position: relative;
        }
    
        #no-data-message {
            font-size: 24px;
            text-align: center;
            color: gray;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
    
        /* Heatmap Styles */
        #heatmap-tooltip {
            position: absolute;
            display: none;
            background: white;
            border: 1px solid #ccc;
            padding: 10px;
            pointer-events: none; 
            z-index: 10; 
        }

        #heatmap-svg rect {
            stroke: #e3e3e3;
            fill-opacity: 0.8;
            transition: fill 0.3s, stroke-width 0.3s;
        }
    
        #heatmap-svg rect:hover {
            stroke: #000;
            stroke-width: 1px;
        }
    
        .axis-label {
            font-size: 14px;
            font-weight: bold;
            fill: #333;
        }
    
        /* Toggle Switch Styles */
        .toggle-container {
            display: flex;
            justify-content: center;
            align-items: center;
            margin-bottom: 20px;
        }
    
        .switch {
            position: relative;
            display: inline-block;
            width: 60px;
            height: 34px;
            margin-right: 10px;
        }
    
        .switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
    
        .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: #ccc;
            transition: .4s;
        }
    
        .slider:before {
            position: absolute;
            content: "";
            height: 26px;
            width: 26px;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
        }
    
        input:checked+.slider {
            background-color: #2196F3;
        }
    
        input:checked+.slider:before {
            transform: translateX(26px);
        }
    
        .slider.round {
            border-radius: 34px;
        }
    
        .slider.round:before {
            border-radius: 50%;
        }
    
        /* Alluvial Diagram Styles */
        .link {
            fill: none;
            stroke-opacity: 0.5;
            cursor: pointer;
            transition: stroke-opacity 0.2s ease-in-out;
        }
    
        .node rect {
            stroke: #000;
            stroke-width: 1px;
            fill-opacity: 0.85;
            transition: fill-opacity 0.2s;
        }
    
        .node text {
            pointer-events: none;
            font-size: 12px;
            text-anchor: middle;
        }
    
        /* Line Graph Styles */
        .line-chart {
            display: flex;
            justify-content: center;
        }
    
        .legend {
            font-size: 12px;
        }
    
        .legend rect {
            stroke-width: 1;
            stroke: #000;
        }
    
        svg {
            max-width: 100%;
            height: auto;
        }
    
        /* FIFA Player Card Styles */
        .fut-player-card {
            position: absolute;
            width: 240px; 
            height: 340px; 
            background-image: url('https://raw.githubusercontent.com/SarangAnilkumar/Data_Visualisation/main/player_card.png');
            background-size: cover;
            background-position: center;
            padding: 10px 15px; 
            color: white;
            font-family: Arial, sans-serif;
            text-align: center;
            display: none;
            z-index: 10;
        }

        /* Show tooltip when visible */
        .fut-player-card.visible {
            display: block;
        }

        /* Top section: player picture */
        .fut-player-card .player-card-top {
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 5px; 
        }

        /* Player picture container */
        .fut-player-card .player-picture {
            width: 120px;
            height: 120px;
            overflow: hidden;
            margin-top: 20px; 
            margin-bottom: 8px;
        }

        .fut-player-card .player-picture img {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        /* Player name styling */
        .fut-player-card .player-name {
            font-size: 1.1rem;
            text-transform: uppercase;
            line-height: 1.2;
            margin-top: 10px;
            margin-bottom: 2px;
        }

        /* Bottom section: player details */
        .fut-player-card .player-card-bottom {
            margin-top: 10px;
            padding: 5px 10px;
        }

        /* Player features list */
        .fut-player-card .player-features {
            text-align: left;
            font-size: 0.7rem;
            margin-top: 10px;
        }

        /* Individual feature row */
        .fut-player-card .feature-row {
            display: flex;
            justify-content: space-between;
            margin: 2.5px 0;
        }

        /* Consistent font style for labels and values */
        .fut-player-card .feature-label {
            font-weight: bold;
            text-transform: capitalize;
        }

        .fut-player-card .feature-value {
            text-align: right;
        }

        /* Scatter Plot Styles */
        #scatterPlotSection {
            margin-top: 40px;
        }

        .scatterPlot-mode-selector {
            display: flex;
            justify-content: center;
            margin-bottom: 20px;
        }

        .scatterPlot-mode-selector button {
            margin: 0 10px;
            padding: 10px 20px;
            background-color: #eee;
            border: none;
            cursor: pointer;
            font-size: 16px;
            border-radius: 8px;
            transition: background-color 0.3s, transform 0.3s;
        }

        .scatterPlot-mode-selector button:hover {
            background-color: #ddd;
            transform: scale(1.05);
        }

        .scatterPlot-mode-selector button.active {
            background-color: #2196F3;
            color: white;
        }

        #scatterPlotTitle {
            text-align: center;
            margin-bottom: 20px;
        }

        /* Tooltip Styles */
        .scatterPlot-tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.8);
            padding: 8px;
            border-radius: 4px;
            font-size: 12px;
            pointer-events: none;
            display: none;
            z-index: 10;
        }

        /* Dropdown Styles */
        .scatterPlot-dropdown-multiselect {
            width: 200px;
            display: inline-block;
            border: 1px solid #007bff;
            border-radius: 4px;
            padding: 8px;
            cursor: pointer;
            position: relative;
            background-color: #f8f9fa;
            margin: 10px;
        }

        .scatterPlot-dropdown-multiselect .scatterPlot-dropbtn {
            width: 100%;
            padding: 8px;
            text-align: left;
            background-color: #f8f9fa;
            border: 1px solid #ccc;
            cursor: pointer;
            border-radius: 4px;
        }

        .scatterPlot-dropdown-multiselect .scatterPlot-dropdown-multiselect-content {
            display: none;
            position: absolute;
            background-color: #f8f9fa;
            min-width: 100%;
            box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
            z-index: 1;
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ccc;
        }

        .scatterPlot-dropdown-multiselect .scatterPlot-dropdown-multiselect-content.show {
            display: block;
        }

        .scatterPlot-dropdown-multiselect.active .scatterPlot-dropdown-multiselect-content {
            display: block;
        }

        .scatterPlot-dropdown-multiselect-content label {
            display: block;
            padding: 8px;
            font-size: 14px;
            cursor: pointer;
            color: #333;
        }

        .scatterPlot-dropdown-multiselect-content label:hover {
            background-color: #e2e6ea;
        }

        #scatterPlotSVG {
            cursor: move; 
        }

        .legend-container {
            width: 150px; 
            max-height: 500px; 
            overflow-y: auto;
            margin-left: 20px; 
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
            cursor: pointer; 
        }
        .legend-item svg {
            flex-shrink: 0;
        }
        .legend-item span {
            margin-left: 5px;
        }
        /* Highlight styles */
        .highlighted-node circle {
            stroke: black;
            stroke-width: 3px;
        }
        .dimmed-node circle {
            opacity: 0.2;
        }

        /* Modal Styles */
        .modal {
            display: none; /* Hidden by default */
            position: fixed; 
            z-index: 1000; 
            left: 0;
            top: 0;
            width: 100%; 
            height: 100%; 
            overflow: auto; 
            background-color: rgba(0,0,0,0.6); 
        }

        .modal-content {
            background-color: #fefefe;
            margin: 60px auto; 
            padding: 20px;
            border: 1px solid #888;
            width: 80%; 
            max-width: 800px;
            border-radius: 8px;
            position: relative;
        }

        .close-button {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        .close-button:hover,
        .close-button:focus {
            color: black;
            text-decoration: none;
            cursor: pointer;
        }

        .slide-container {
            position: relative;
        }

        .slide {
            display: none;
        }

        .slide.active {
            display: block;
        }

        .slide-content {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
        }

        .slide-content table {
            width: 100%;
            border-collapse: collapse;
        }

        .slide-content th, .slide-content td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid #ddd;
        }

        .slide-content tr:hover {
            background-color: #f1f1f1;
        }

        .slide-navigation {
            margin-top: 20px;
            text-align: center;
        }

        .nav-button {
            background-color: #2196F3;
            color: white;
            padding: 12px 24px;
            margin: 0 10px;
            border: none;
            cursor: pointer;
            border-radius: 4px;
            font-size: 16px;
        }

        .nav-button:hover {
            background-color: #0b7dda;
        }

        @media screen and (max-width: 600px) {
            .modal-content {
                width: 95%;
                margin: 30px auto;
            }

            .nav-button {
                padding: 10px 20px;
                font-size: 14px;
            }
        }

         .summary-box-container {
            display: flex;
            flex-direction: column;
            gap: 20px; 
            position: absolute;
            top: 200px; 
            right: 80px; 
            width: 200px;
            height: 200px;
            z-index: 1000;
        }

        /* Shared style for both boxes */
        .summary-box {
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background-color: #ffffff;
            box-shadow: 0px 4px 12px rgba(0, 0, 0, 0.1);
            font-family: 'Arial', sans-serif;
            color: #333;
        }

        .summary-box h3 {
            margin: 0;
            font-size: 18px;
            color: #444;
            text-align: center;
            font-weight: bold;
        }

        .summary-box ul {
            list-style: none;
            padding: 0;
            margin: 10px 0 0;
        }

        .summary-box li {
            font-size: 14px;
            margin: 5px 0;
            line-height: 1.5;
        }

        .summary-box p {
            margin: 5px 0;
            font-size: 14px;
            font-weight: bold;
            color: #007bff;
        }

        /* Left border indicator for highest and lowest boxes */
        .highest-summary-box {
            border-left: 15px solid #28a745; /* Green for highest */
        }

        .lowest-summary-box {
            border-left: 15px solid #dc3545; /* Red for lowest */
        }

    </style>
    
</head>

<body>

    
    <!-- Page Header -->
    <header data-intro="Welcome to the Premier League Dashboard! This dashboard provides insights into team performance, player transfers, and more." data-step="1">
        <h1><strong>Premier League Tactics & Transfers Dashboard</strong></h1>
    </header>

    <!-- Help Button to Restart the Tour -->
    <button id="helpButton" class="btn btn-info" style="position: fixed; top: 20px; right: 20px; z-index: 1000;">
        Help
    </button>


    <!-- Bar Chart Section: Formation vs Win Percentage -->
    <section id="bar-chart-section">    
        <h2>Formation Impact on Win Rates: Premier League Tactical Analysis</h2>

        <!-- Filters for Bar Chart -->
        <div class="container filter-section">
            <!-- Season Filter -->
            <label for="bar-season-select" class="filter-label">Select Seasons:</label>
            <div id="bar-season-select" class="dropdown-multiselect" role="menu" aria-expanded="false">
                <span>Select Seasons</span>
                <div id="bar-season-options" class="dropdown-multiselect-content"></div>
            </div>

            <!-- Formation Filter -->
            <label for="bar-formation-select" class="filter-label">Select Formations:</label>
            <div id="bar-formation-select" class="dropdown-multiselect" role="menu" aria-expanded="false">
                <span>Select Formations</span>
                <div id="bar-formation-options" class="dropdown-multiselect-content"></div>
            </div>
        </div>

        <!-- Bar Chart Container -->
        <div id="chart-container" style="position: relative;">
            <div id="winGraph"></div>
            <div id="no-data-message" class="hidden">Select details to be displayed</div>
            <div id="loading-message" class="hidden">Loading data...</div>
            <div id="error-message" class="hidden">Error loading data, please try again later.</div>
        </div>

        <!-- Tooltip for Bar Chart Mouseover -->
        <div id="bar-chart-tooltip" class="tooltip" role="tooltip" aria-hidden="true"></div>
        <!-- Tooltip for Bar Chart Click -->
        <div id="bar-chart-click-tooltip" class="bar-chart-click-tooltip" role="tooltip" aria-hidden="true"></div>

        <div id="summary-box-container" class="summary-box-container">
            <!-- Highest Win Percentage Box -->
            <div id="highest-summary-box" class="summary-box highest-summary-box">
                <h3>Highest Win %</h3>
                <p>Formation: <span id="highest-formation">-</span></p>
                <ul>
                    <li><strong>Games:</strong> <span id="highest-games">-</span></li>
                    <li><strong>Wins:</strong> <span id="highest-wins">-</span></li>
                    <li><strong>Losses:</strong> <span id="highest-losses">-</span></li>
                    <li><strong>Draws:</strong> <span id="highest-draws">-</span></li>
                </ul>
            </div>
            <!-- Lowest Win Percentage Box -->
            <div id="lowest-summary-box" class="summary-box lowest-summary-box">
                <h3>Lowest Win %</h3>
                <p>Formation: <span id="lowest-formation">-</span></p>
                <ul>
                    <li><strong>Games:</strong> <span id="lowest-games">-</span></li>
                    <li><strong>Wins:</strong> <span id="lowest-wins">-</span></li>
                    <li><strong>Losses:</strong> <span id="lowest-losses">-</span></li>
                    <li><strong>Draws:</strong> <span id="lowest-draws">-</span></li>
                </ul>
            </div>
        </div>
    </section>

    <!-- Heatmap Section -->
    <section id="heatmap-section">
        <h2>Formation Matchups: Win Percentages in Head-to-Head Tactics</h2>
        <!-- Heatmap Filters and Chart Container -->
        <div class="filter-section">
            <!-- Heatmap Dropdown Filters -->
            <label for="heatmap-order">Order by:</label>
            <select id="heatmap-order">
                <option value="name">By Formation Name</option>
                <option value="cellWinPercentage">By Win Percentage</option>
            </select>
            <div id="heatmap-formation-select" class="dropdown-multiselect">
                <span>Select Formations</span>
                <div class="dropdown-multiselect-content" id="heatmap-formation-options"></div>
            </div>
            <div id="heatmap-oppformation-select" class="dropdown-multiselect">
                <span>Select Opponent Formations</span>
                <div class="dropdown-multiselect-content" id="heatmap-oppformation-options"></div>
            </div>
        </div>
        <div id="heatmap-container">
            <div id="heatmap"></div>
            <!-- Tooltip Div -->
            <div id="heatmap-tooltip" style="position: absolute; display: none; background: white; border: 1px solid #ccc; padding: 10px;"></div>
        </div>
    </section>

    <!-- Alluvial Diagram and Line Graph Toggle Section -->
    <section id="alluvial-line-toggle-section">
        <!-- Toggle Switch -->
        <div class="toggle-container">
            <label class="switch">
                <input type="checkbox" id="graphToggle">
                <span class="slider round"></span>
            </label>
            <span id="toggleLabel">Alluvial Diagram</span>
        </div>
    </section>

    <!-- Alluvial Diagram Section -->
    <section id="alluvialContainer">
        <h2>Player Transfer Flows: Premier League Club Movement Dynamics</h2>
        <!-- Season Filter and Diagram Container -->
        <label for="alluvial-season-select">Select Season:</label>
        <select id="alluvial-season-select"></select>
        <div id="chart"></div>
        <div id="fifa-tooltip" class="fut-player-card">
            <div class="player-card-top">
                <div class="player-picture">
                    <img id="tooltip-player-image" src="https://b.fssta.com/uploads/application/soccer/competition-logos/EnglishPremierLeague.png" alt="Player Image">
                </div>
                <div class="player-name" id="tooltip-name">Player Name</div>
            </div>
            <div class="player-card-bottom">
                <div class="player-info">
                    <div class="player-features">
                        <div class="feature-row">
                            <span class="feature-label">Age:</span>
                            <span class="feature-value" id="tooltip-age">22</span>
                        </div>
                        <div class="feature-row">
                            <span class="feature-label">Position:</span>
                            <span class="feature-value" id="tooltip-position">MID</span>
                        </div>
                        <div class="feature-row">
                            <span class="feature-label">Nationality:</span>
                            <span class="feature-value" id="tooltip-nationality">England</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>        
    </section>
 
    <!-- Line Graph Section -->
    <section id="lineGraphContainer" style="display: none;">
        <h2>Team Performance Trends: Win Percentage Evolution Over Seasons</h2>
        <!-- Season and Team Filters -->
        <div class="filters">
            <label for="lineSeasonSelect">Select Season:</label>
            <select id="lineSeasonSelect"></select>
            <!-- Team Filter Button and Dropdown Structure -->
            <label for="teamSelect">Select Teams (up to 2):</label>
            <div id="teamDropdown" class="dropdown-multiselect">
                <button id="teamSelectButton" class="dropbtn">Select Teams</button>
                <div id="teamDropdownContent" class="dropdown-multiselect-content">
                </div>
            </div>
        </div>
        <div class="line-chart">
            <svg id="line-chart-svg"></svg>
        </div>
        <div id="line-chart-tooltip" class="tooltip"></div>
    </section>

    <!-- Scatter Plot Section -->
    <section id="scatterPlotSection">
        <h2 id="scatterPlotTitle">Expenditure vs. Success: Premier League Investment and Performance Correlation</h2>

        <!-- Mode Selector Buttons -->
        <div class="scatterPlot-mode-selector">
            <button id="scatterPlot-mode1Button" class="active">Mode 1: Overall Performance</button>
            <button id="scatterPlot-mode2Button">Mode 2: Team Seasons Comparison</button>
        </div>

        <!-- Filters -->
        <div id="scatterPlot-seasonFilter" class="scatterPlot-dropdown-multiselect">
            <button class="scatterPlot-dropbtn">Select Seasons</button>
            <div class="scatterPlot-dropdown-multiselect-content" id="scatterPlot-seasonDropdown">
            </div>
        </div>

        <div id="scatterPlot-teamFilter" class="scatterPlot-dropdown-multiselect">
            <button class="scatterPlot-dropbtn">Select Teams (up to 2)</button>
            <div class="scatterPlot-dropdown-multiselect-content" id="scatterPlot-teamDropdownContent">
            </div>
        </div>

        <!-- Scatter Plot Container -->
        <div style="display: flex;">
            <svg id="scatterPlotSVG"></svg>
            <div id="scatterPlotLegendContainer" class="legend-container"></div>
        </div>

        <!-- Tooltip for Scatter Plot -->
        <div id="scatterPlotTooltip" style="position: absolute; display: none; background: white; border: 1px solid #ccc; padding: 10px;"></div>
    </section>

    <!-- Modal Popup for Scatter Plot Mode 2 -->
    <div id="scatterPlotModal" class="modal">
        <div class="modal-content">
            <span class="close-button">&times;</span>
            <!-- Slide Content -->
            <div class="slide-container">
                <!-- Slide 1: Transfers In -->
                <div class="slide" id="slide1">
                    <h2>Players Transferred In</h2>
                    <div class="slide-content" id="transfersInContent">
                    </div>
                </div>
                <!-- Slide 2: Transfers Out -->
                <div class="slide" id="slide2">
                    <h2>Players Transferred Out</h2>
                    <div class="slide-content" id="transfersOutContent">
                    </div>
                </div>
                <!-- Navigation Buttons -->
                <div class="slide-navigation">
                    <button id="prevSlideButton" class="nav-button">&laquo; Previous</button>
                    <button id="nextSlideButton" class="nav-button">Next &raquo;</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Tutorial Script -->
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            // Remove 'tutorialSeen' from localStorage to start the tutorial every time
            localStorage.removeItem("tutorialSeen");

            // Get references to containers
            const lineGraphContainer = document.getElementById("lineGraphContainer");
            const alluvialContainer = document.getElementById("alluvialContainer");
            const scatterPlotSection = document.getElementById("scatterPlotSection");

            // Get references to mode buttons in the scatter plot
            const mode1Button = document.getElementById('scatterPlot-mode1Button');
            const mode2Button = document.getElementById('scatterPlot-mode2Button');

            // Hide the line graph container on load
            lineGraphContainer.style.display = 'none';

            // Initialize Intro.js
            const intro = introJs().setOptions({
                skipLabel: 'Skip',
                doneLabel: 'Finish',
                showStepNumbers: false,
                overlayOpacity: 0.6,
                steps: [
                    {
                        intro: `
                                <h3>Welcome to the Premier League Data Visualization!</h3>
                                <p>In this tutorial, we'll explore various graphs that provide insights into Premier League teams' tactics, performances, and transfer activities.</p>
                            `
                    },
                    {
                        element: document.querySelector('#bar-chart-section'),
                        intro: `
                                <h3>Formation Impact on Win Rates</h3>
                                <p>This bar chart analyzes how different formations affect win percentages in the Premier League.</p>
                                <ul>
                                    <li><strong>Y-Axis:</strong> Win Percentage (%)</li>
                                    <li><strong>X-Axis:</strong> Football formations used by teams</li>
                                </ul>
                                <p>By hovering over the bars, you can see the exact win percentage for each formation.</p>
                                <h4><strong>Click on a bar to see which teams used that formation in which seasons.</strong></h4>
                            `
                    },
                    {
                        element: document.querySelector('#bar-season-select'),
                        intro: `
                                <h3>Filter by Seasons</h3>
                                <p>You can filter the data by selecting specific seasons. This allows you to see how formations performed in different years.</p>
                            `
                    },
                    {
                        element: document.querySelector('#bar-formation-select'),
                        intro: `
                                <h3>Filter by Formations</h3>
                                <p>Select formations to focus on specific tactical setups. This helps in comparing the effectiveness of different formations.</p>
                            `
                    },
                    {
                        element: document.querySelector
                        
                        ('#summary-box-container'),
                        intro: `
                                <h3>Summary</h3>
                                <p>Get an instant overview of the highest and lowest performing formations.</p>
                            `
                    },
                    {
                        element: document.querySelector('#heatmap-section'),
                        intro: `
                                <h3>Win Percentages in Head-to-Head Tactics</h3>
                                <p>This heatmap visualizes the win percentages based on your team's formation against opponent formations.</p>
                                <ul>
                                    <li><strong>Color Scale:</strong> Represents win percentage from low (light blue) to high (dark blue)</li>
                                </ul>
                                <p>Hover over a cell to see the win percentage for that formation matchup.</p>
                                <p>A color legend has been added to help interpret the win percentages represented by the colors.</p>
                            `
                    },
                    {
                        element: document.querySelector('#heatmap-formation-select'),
                        intro: `
                                <h3>Select Formations</h3>
                                <p>Use this filter to select which formations to display on the heatmap.</p>
                            `
                    },
                    {
                        element: document.querySelector('#heatmap-oppformation-select'),
                        intro: `
                                <h3>Select Opponent Formations</h3>
                                <p>Choose opponent formations to see how your team's formations perform against specific opponent setups.</p>
                            `
                    },
                    {
                        element: document.querySelector('#alluvialContainer'),
                        intro: `
                                <h3>Player Transfer Flows: Premier League Club Movement Dynamics</h3>
                                <p>This alluvial diagram shows the flow of formations used by teams over time, highlighting the most popular tactical setups.</p>
                                <p>Hover over the flows to see the proportion of teams using specific formations from one season to the next.</p>
                            `
                    },
                    {
                        element: document.querySelector('#alluvial-season-select'),
                        intro: `
                                <h3>Alluvial Diagram: Formation Flow</h3>
                                <p>Choose a Premier League season to view player transfers between clubs. The diagram will update to show the flow of players between teams for the selected season.</p>
                            `
                    },
                    {
                        element: document.querySelector('#lineGraphContainer'),
                        intro: `
                                <h3>Team Performance Trends: Win Percentage Evolution Over Seasons</h3>
                                <p>This line chart compares the average transfer fees paid and the average market values of players over time.</p>
                                <p>It helps identify trends in the transfer market and the valuation of players.</p>
                            `
                    },
                    {
                        element: document.querySelector('#lineSeasonSelect'),
                        intro: `
                                <h3>Select Season for Line Chart</h3>
                                <p>Choose a Premier League season to view team performance trends. The line chart will display win percentages for selected teams throughout the chosen season.</p>
                            `
                    },
                    {
                        element: document.querySelector('.dropdown-multiselect .dropbtn'),
                        intro: `
                                <h3>Select Teams for Line Chart</h3>
                                <p>Choose teams to see how their spending and player valuations have changed over time.</p>
                            `
                    },
                    {
                        element: document.querySelector('#scatterPlotSection'),
                        intro: `
                                <h3>Expenditure vs. Success: Premier League Investment and Performance Correlation</h3>
                                <p>This scatter plot explores the relationship between teams' transfer spending and their win percentages.</p>
                                <ul>
                                    <li><strong>X-Axis:</strong> Total Fees Paid (€)</li>
                                    <li><strong>Y-Axis:</strong> Win Percentage (%)</li>
                                    <li><strong>Bubble Size:</strong> Total Market Value (€)</li>
                                </ul>
                                <p>The scatter plot has two modes for deeper analysis.</p>
                            `
                    },
                    {
                        element: '#scatterPlot-mode1Button',
                        intro: `
                            <h3>Mode 1: Overall Performance</h3>
                            <p>In Mode 1, you can see the aggregate transfer fees and win percentages for teams over selected seasons.</p>
                            <p>A trendline is added to show the general relationship between spending and performance.</p>
                            <h4>Click on a team in the legend to highlight it on the scatter plot.</h4>
                        `
                    },
                    {
                        element: '#scatterPlot-seasonFilter',
                        intro: `
                            <h3>Select Seasons</h3>
                            <p>Use this filter to select the seasons you want to analyze. The scatter plot will update to reflect data from the selected seasons.</p>
                        `
                    },
                    {
                        element: '#scatterPlot-mode2Button',
                        intro: `
                            <h3>Mode 2: Team Seasons Comparison</h3>
                            <p>Mode 2 allows you to compare the transfer activities and performances of up to two teams across different seasons.</p>
                            <h4>Click on a data point to view detailed information about player transfers for that team and season.</h4>
                        `
                    },
                    {
                        element: '#scatterPlot-teamFilter',
                        intro: `
                            <h3>Select Teams</h3>
                            <p>In Mode 2, select up to two teams to compare their transfer spending and win percentages over the selected seasons.</p>
                        `
                    },
                    {
                        intro: `
                                <h3>End of Tutorial</h3>
                                <p>Thank you for taking the time to explore the Premier League Data Visualization!</p>
                                <p>Feel free to interact with the graphs, apply filters, and discover insights.</p>
                            `
                    }
                ]
            });

            // Function to toggle between Alluvial Diagram and Line Chart
            function showLineGraph(show) {
                if (show) {
                    alluvialContainer.style.display = 'none';
                    lineGraphContainer.style.display = 'block';
                    const graphToggle = document.getElementById("graphToggle");
                    if (graphToggle && !graphToggle.checked) {
                        graphToggle.checked = true;
                        document.getElementById("toggleLabel").textContent = "Line Graph";
                    }
                } else {
                    alluvialContainer.style.display = 'block';
                    lineGraphContainer.style.display = 'none';
                    const graphToggle = document.getElementById("graphToggle");
                    if (graphToggle && graphToggle.checked) {
                        graphToggle.checked = false;
                        document.getElementById("toggleLabel").textContent = "Alluvial Diagram";
                    }
                }
            }

            // Function to switch scatter plot modes
            function switchScatterPlotMode(mode) {
                if (mode === 1 && mode1Button && mode2Button) {
                    mode1Button.classList.add('active');
                    mode2Button.classList.remove('active');
                    // Trigger the click event to switch modes
                    mode1Button.click();
                } else if (mode === 2 && mode1Button && mode2Button) {
                    mode2Button.classList.add('active');
                    mode1Button.classList.remove('active');
                    // Trigger the click event to switch modes
                    mode2Button.click();
                }
            }

            // Steps that require Mode 2
            const mode2Steps = [
                document.querySelector('#scatterPlot-mode2Button'),
                document.querySelector('#scatterPlot-teamFilter')
            ];

            // Event listener to control display and modes during the tutorial
            intro.onbeforechange(function (targetElement) {
                // Show line graph only when at the line graph step
                if (targetElement === lineGraphContainer) {
                    showLineGraph(true);
                } else if (targetElement === alluvialContainer) {
                    showLineGraph(false);
                }

                // Switch to Mode 2 when the tutorial reaches steps that require Mode 2
                if (mode2Steps.includes(targetElement)) {
                    switchScatterPlotMode(2);
                } else {
                    switchScatterPlotMode(1);
                }
            });

            // Reset view after tutorial finishes or is exited
            intro.oncomplete(() => {
                showLineGraph(false);
                switchScatterPlotMode(1); // Switch back to Mode 1
            });
            intro.onexit(() => {
                showLineGraph(false);
                switchScatterPlotMode(1); // Switch back to Mode 1
            });

            // Automatically start the tutorial every time the page loads
            intro.start();

            // Allow the "Help" button to re-trigger the tutorial from the start
            const helpButton = document.getElementById("helpButton");
            if (helpButton) {
                helpButton.onclick = function () {
                    intro.start();
                };
            } else {
                console.error('Help button with ID "helpButton" not found.');
            }

            // Handle toggle switch for Alluvial Diagram and Line Chart
            const graphToggle = document.getElementById("graphToggle");
            if (graphToggle) {
                graphToggle.addEventListener("change", function () {
                    if (graphToggle.checked) {
                        showLineGraph(true);
                        document.getElementById("toggleLabel").textContent = "Line Graph";
                    } else {
                        showLineGraph(false);
                        document.getElementById("toggleLabel").textContent = "Alluvial Diagram";
                    }
                });
            } else {
                console.error('Toggle switch with ID "graphToggle" not found.');
            }
        });
    </script>

    <!-- Scripts for Visualization Initialization and Interactivity -->
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/js/bootstrap.bundle.min.js"></script>
    
    <!-- Bar Chart Script -->
    <script>
        (function () {
            const noDataMessage = document.getElementById("no-data-message");
            const loadingMessage = document.getElementById("loading-message");
            const errorMessage = document.getElementById("error-message");
    
            // Show loading message initially
            loadingMessage.classList.remove("hidden");
    
            // Function to close other open dropdowns
            function closeOtherDropdowns(currentDropdown) {
                const dropdowns = document.querySelectorAll('.dropdown-multiselect');
                dropdowns.forEach(function (dropdown) {
                    if (dropdown !== currentDropdown) {
                        dropdown.classList.remove('active');
                        const content = dropdown.querySelector('.dropdown-multiselect-content');
                        if (content) content.style.display = 'none';
                    }
                });
            }
    
            // Toggle dropdown multiselect
            function toggleDropdown(dropdown) {
                const content = dropdown.querySelector('.dropdown-multiselect-content');
                closeOtherDropdowns(dropdown); // Close other dropdowns
                dropdown.classList.toggle("active");
                content.style.display = dropdown.classList.contains("active") ? "block" : "none";
            }
    
            // Close all dropdowns if clicking outside
            document.addEventListener('click', function (event) {
                if (!event.target.closest('.dropdown-multiselect')) {
                    closeOtherDropdowns(null); // Close all if clicking outside
                }
            });
    
            // Load the data
            d3.csv("https://raw.githubusercontent.com/SarangAnilkumar/Data_Visualisation/main/football_stats.csv")
                .then(function (data) {
                    // Hide loading message after data loads
                    loadingMessage.classList.add("hidden");
    
                    // Extract unique values for filters
                    const seasons = [...new Set(data.map(d => d.Season))];
                    const formations = [...new Set(data.map(d => d.Formation))];
    
                    // Populate the dropdowns
                    const seasonOptions = document.getElementById('bar-season-options');
                    const formationOptions = document.getElementById('bar-formation-options');
    
                    seasons.forEach(season => {
                        const label = document.createElement('label');
                        label.innerHTML = `<input type="checkbox" value="${season}" checked> ${season}`;
                        seasonOptions.appendChild(label);
                    });
    
                    formations.forEach(formation => {
                        const label = document.createElement('label');
                        label.innerHTML = `<input type="checkbox" value="${formation}" checked> ${formation}`;
                        formationOptions.appendChild(label);
                    });
    
                    // Toggle dropdown functionality
                    document.getElementById('bar-season-select').onclick = function () {
                        toggleDropdown(this);
                    };
                    document.getElementById('bar-formation-select').onclick = function () {
                        toggleDropdown(this);
                    };
    
                    // Bar chart setup
                    const width = 800,
                        height = 400,
                        margin = { top: 20, right: 20, bottom: 80, left: 100 };
    
                    const svgWin = d3.select("#winGraph").append("svg")
                        .attr("id", "bar-chart-svg")
                        .attr("width", width + margin.left + margin.right)
                        .attr("height", height + margin.top + margin.bottom)
                        .append("g")
                        .attr("transform", `translate(${margin.left}, ${margin.top})`);
    
                    const xScale = d3.scaleBand().range([0, width]).padding(0.2);
                    const yScale = d3.scaleLinear().range([height, 0]);
    
                    // Define axes groups
                    const xAxisGroup = svgWin.append("g")
                        .attr("class", "x axis")
                        .attr("transform", `translate(0, ${height})`);
    
                    const yAxisGroup = svgWin.append("g")
                        .attr("class", "y axis");
    
                    // Add X-axis label
                    svgWin.append("text")
                        .attr("class", "x label")
                        .attr("x", width / 2)
                        .attr("y", height + 70)
                        .attr("text-anchor", "middle")
                        .attr("font-size", "14px")
                        .text("Formations");
    
                    // Add Y-axis label
                    svgWin.append("text")
                        .attr("class", "y label")
                        .attr("transform", "rotate(-90)")
                        .attr("y", -60)
                        .attr("x", -(height / 2))
                        .attr("text-anchor", "middle")
                        .attr("font-size", "14px")
                        .text("Win Percentage (%)");
    
                    // Function to update the bar chart
                    function updateChart(initial = false) {
                        const selectedSeasons = Array.from(document.querySelectorAll('#bar-season-options input:checked')).map(input => input.value);
                        const selectedFormations = Array.from(document.querySelectorAll('#bar-formation-options input:checked')).map(input => input.value);
    
                        const filteredData = data.filter(d =>
                            selectedSeasons.includes(d.Season) &&
                            selectedFormations.includes(d.Formation)
                        );
    
                        // Show no data message if no data matches the filters
                        if (!filteredData.length) {
                            svgWin.selectAll(".bar").remove();  
                            noDataMessage.classList.remove("hidden");  
                            return;
                        } else {
                            noDataMessage.classList.add("hidden");  // Hide "no data" message
                        }

                        updateSummaryBox(filteredData);

                        // If no data matches the filters, stop further updates
                        if (filteredData.length === 0) {
                            svgWin.selectAll(".bar").remove();  // Clear the chart
                            noDataMessage.classList.remove("hidden");  // Show "no data" message
                            return;
                        }


                        function updateSummaryBox(filteredData) {
                            const defaultContent = {
                                formation: '-',
                                games: '-',
                                wins: '-',
                                losses: '-',
                                draws: '-',
                                winPercentage: '-'
                            };

                            function updateStats(boxIdPrefix, content) {
                                document.getElementById(`${boxIdPrefix}-formation`).textContent = content.formation;
                                document.getElementById(`${boxIdPrefix}-games`).textContent = content.games;
                                document.getElementById(`${boxIdPrefix}-wins`).textContent = content.wins;
                                document.getElementById(`${boxIdPrefix}-losses`).textContent = content.losses;
                                document.getElementById(`${boxIdPrefix}-draws`).textContent = content.draws;
                            }

                            if (!filteredData || filteredData.length === 0) {
                                updateStats('highest', defaultContent);
                                updateStats('lowest', defaultContent);
                                return;
                            }

                            const formationWins = d3.rollup(
                                filteredData,
                                v => ({
                                    totalGames: v.length,
                                    wins: v.filter(d => d.Result === 'W').length,
                                    losses: v.filter(d => d.Result === 'L').length,
                                    draws: v.filter(d => d.Result === 'D').length,
                                    winPercentage: (v.filter(d => d.Result === 'W').length / v.length) * 100
                                }),
                                d => d.Formation
                            );

                            const formationData = Array.from(formationWins, ([formation, values]) => ({
                                formation: formation,
                                ...values
                            }));

                            const highestWin = formationData.reduce((max, curr) => curr.winPercentage > max.winPercentage ? curr : max, formationData[0]);
                            const lowestWin = formationData.reduce((min, curr) => curr.winPercentage < min.winPercentage ? curr : min, formationData[0]);

                            updateStats('highest', {
                                formation: highestWin.formation,
                                games: highestWin.totalGames,
                                wins: highestWin.wins,
                                losses: highestWin.losses,
                                draws: highestWin.draws
                            });

                            updateStats('lowest', {
                                formation: lowestWin.formation,
                                games: lowestWin.totalGames,
                                wins: lowestWin.wins,
                                losses: lowestWin.losses,
                                draws: lowestWin.draws
                            });
                        }
    
                        // Process data for chart
                        const formationWins = d3.rollup(
                            filteredData,
                            v => ({
                                totalGames: v.length,
                                wins: v.filter(d => d.Result === 'W').length,
                                winPercentage: (v.filter(d => d.Result === 'W').length / v.length) * 100
                            }),
                            d => d.Formation
                        );
    
                        const formationData = Array.from(formationWins, ([formation, values]) => ({
                            Formation: formation,
                            WinPercentage: values.winPercentage
                        }));
    
                        // Sort data by win percentage
                        formationData.sort((a, b) => b.WinPercentage - a.WinPercentage);
    
                        // Update scales
                        xScale.domain(formationData.map(d => d.Formation));
                        yScale.domain([0, d3.max(formationData, d => d.WinPercentage)]);
    
                        // Update axes
                        xAxisGroup.transition().duration(1000).call(d3.axisBottom(xScale))
                            .selectAll("text")
                            .attr("transform", "rotate(-45)")
                            .style("text-anchor", "end");
    
                        yAxisGroup.transition().duration(1000).call(d3.axisLeft(yScale));
    
                        // Update bars
                        const bars = svgWin.selectAll(".bar")
                            .data(formationData, d => d.Formation);
    
                        // ENTER phase
                        const barsEnter = bars.enter()
                            .append("rect")
                            .attr("class", "bar")
                            .attr("x", d => xScale(d.Formation))
                            .attr("y", height)
                            .attr("width", xScale.bandwidth())
                            .attr("height", 0)
                            .attr("fill", "steelblue")
                            .on("mouseover", function (event, d) {
                                d3.select("#bar-chart-tooltip")
                                    .style("opacity", 1)
                                    .html(`Formation: ${d.Formation}<br>Win Percentage: ${d.WinPercentage.toFixed(2)}%`)
                                    .style("left", (event.pageX + 10) + "px")
                                    .style("top", (event.pageY - 10) + "px");
                            })
                            .on("mouseout", function () {
                                d3.select("#bar-chart-tooltip").style("opacity", 0);
                            })
                            .on("click", function(event, d) {
                                const formation = d.Formation;
                                const formationDataFiltered = filteredData.filter(f => f.Formation === formation);
    
                                // Create a mapping from team to seasons
                                const teamSeasonsMap = d3.rollup(
                                    formationDataFiltered,
                                    v => [...new Set(v.map(d => d.Season))],
                                    d => d.Team
                                );
    
                                let tooltipContent = `<strong>Formation:</strong> ${formation}<br>`;
                                tooltipContent += `<strong>Teams and Seasons:</strong><br>`;
                                tooltipContent += `<div><table>`;
                                teamSeasonsMap.forEach((seasons, team) => {
                                    tooltipContent += `<tr><td><strong>${team}</strong></td><td>${seasons.join(', ')}</td></tr>`;
                                });
                                tooltipContent += `</table></div>`;
    
                                // Position the tooltip
                                const tooltip = d3.select("#bar-chart-click-tooltip");
                                tooltip.html(tooltipContent)
                                    .attr("class", "bar-chart-click-tooltip show");
    
                                // Get the tooltip dimensions
                                const tooltipNode = tooltip.node();
                                const tooltipRect = tooltipNode.getBoundingClientRect();
    
                                let left = event.pageX + 10;
                                let top = event.pageY - 10;
    
                                if (left + tooltipRect.width > window.innerWidth) {
                                    left = event.pageX - tooltipRect.width - 10;
                                }
    
                                if (top + tooltipRect.height > window.innerHeight) {
                                    top = event.pageY - tooltipRect.height - 10;
                                }
    
                                tooltip.style("left", left + "px")
                                    .style("top", top + "px");
    
                                // Stop propagation to prevent closing dropdowns
                                event.stopPropagation();
                            });
    
                        // UPDATE phase
                        bars.merge(barsEnter)
                            .transition()
                            .duration(1000)
                            .attr("x", d => xScale(d.Formation))
                            .attr("y", d => yScale(d.WinPercentage))
                            .attr("height", d => height - yScale(d.WinPercentage))
                            .attr("width", xScale.bandwidth());
    
                        // EXIT phase
                        bars.exit()
                            .transition()
                            .duration(1000)
                            .attr("y", height)
                            .attr("height", 0)
                            .remove();
    
                        // Entrance animation for initial load
                        if (initial) {
                            barsEnter.transition()
                                .duration(1000)
                                .attr("y", d => yScale(d.WinPercentage))
                                .attr("height", d => height - yScale(d.WinPercentage));
                        }
                    }
    
                    // Listen for changes to the filters
                    document.querySelectorAll('#bar-season-options input, #bar-formation-options input')
                        .forEach(checkbox => checkbox.addEventListener('change', () => updateChart()));
    
                    // Hide the click tooltip when clicking elsewhere
                    document.addEventListener('click', function(event) {
                        // If the click is outside the tooltip and the bars, hide the tooltip
                        const tooltip = d3.select("#bar-chart-click-tooltip");
                        if (!event.target.closest('#bar-chart-click-tooltip') && !event.target.closest('rect')) {
                            tooltip.attr("class", "bar-chart-click-tooltip hide");
                        }
                    });
    
                    // Prevent tooltip from closing when clicking inside it
                    d3.select("#bar-chart-click-tooltip").on("click", function(event) {
                        event.stopPropagation();
                    });
    
                    // Initial chart update with entrance animation
                    updateChart(true);
                })
                .catch(function (error) {
                    console.error("Error loading data:", error);
    
                    // Hide loading and no-data messages, show the error message
                    loadingMessage.classList.add("hidden");
                    noDataMessage.classList.add("hidden");
                    errorMessage.classList.remove("hidden");
                });
        })();
    </script>
    
    <!-- Heatmap Script -->
    <script>
        (function () {
            // Function to toggle dropdown display and ensure only one is open at a time
            function toggleDropdown(dropdown) {
                const content = dropdown.querySelector('.dropdown-multiselect-content');
                const isActive = dropdown.classList.contains('active');

                closeOtherDropdowns();  // Close other open dropdowns
                dropdown.classList.toggle('active', !isActive);
                content.style.display = isActive ? 'none' : 'block';
            }

            // Close all open dropdowns
            function closeOtherDropdowns() {
                document.querySelectorAll('.dropdown-multiselect').forEach(dropdown => {
                    dropdown.classList.remove('active');
                    const content = dropdown.querySelector('.dropdown-multiselect-content');
                    if (content) content.style.display = 'none';
                });
            }

            // Close dropdowns if clicking outside
            document.addEventListener('click', function (event) {
                if (!event.target.closest('.dropdown-multiselect')) {
                    closeOtherDropdowns();  // Close all if clicking outside any dropdown
                }
            });

            // Attach event listeners for dropdowns
            document.getElementById('heatmap-formation-select').onclick = function (event) {
                event.stopPropagation();  // Prevent triggering document click listener
                toggleDropdown(this);
            };
            document.getElementById('heatmap-oppformation-select').onclick = function (event) {
                event.stopPropagation();  // Prevent triggering document click listener
                toggleDropdown(this);
            };

            // Heatmap setup and initialization
            const heatmapContainer = d3.select("#heatmap");
            const heatmapTooltip = d3.select("#heatmap-tooltip");

            // Set dimensions for the heatmap
            const margin = { top: 50, right: 50, bottom: 150, left: 150 },
                width = 1000 - margin.left - margin.right,
                height = 800 - margin.top - margin.bottom;

            const svg = heatmapContainer.append("svg")
                .attr("id", "heatmap-svg")
                .attr("width", width + margin.left + margin.right + 200) // Extra space for legend
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform", `translate(${margin.left}, ${margin.top})`);

            const xScale = d3.scaleBand().range([0, width]).padding(0.05);
            const yScale = d3.scaleBand().range([0, height]).padding(0.05);
            const colorScale = d3.scaleSequential(d3.interpolateViridis).domain([0, 100]);

            const xAxisGroup = svg.append("g").attr("transform", `translate(0, ${height})`);
            const yAxisGroup = svg.append("g");

            // Create a group for the legend
            const legendWidth = 20;
            const legendHeight = 300;
            const legendGroup = svg.append("g")
                .attr("class", "legend")
                .attr("transform", `translate(${width + 50}, ${height / 2 - legendHeight / 2})`);

            // Load data and populate dropdowns
            d3.csv("https://raw.githubusercontent.com/SarangAnilkumar/Data_Visualisation/main/football_stats.csv")
                .then(data => {
                    const formationOppData = d3.rollups(
                        data.map(d => ({
                            formation: d.Formation,
                            oppFormation: d["Opp Formation"],
                            result: d.Result
                        })),
                        v => ({ winPercentage: (v.filter(d => d.result === 'W').length / v.length) * 100 }),
                        d => d.formation,
                        d => d.oppFormation
                    ).flatMap(([formation, oppFormations]) =>
                        oppFormations.map(([oppFormation, values]) => ({
                            formation,
                            oppFormation,
                            winPercentage: values.winPercentage
                        }))
                    );

                    let formations = Array.from(new Set(formationOppData.map(d => d.formation))).sort(d3.ascending);
                    let oppFormations = Array.from(new Set(formationOppData.map(d => d.oppFormation))).sort(d3.ascending);

                    // Populate formation filter dropdowns
                    const formationOptions = d3.select("#heatmap-formation-options");
                    formations.forEach(formation => {
                        formationOptions.append("label")
                            .html(`<input type="checkbox" value="${formation}" checked> ${formation}`);
                    });

                    const oppFormationOptions = d3.select("#heatmap-oppformation-options");
                    oppFormations.forEach(oppFormation => {
                        oppFormationOptions.append("label")
                            .html(`<input type="checkbox" value="${oppFormation}" checked> ${oppFormation}`);
                    });

                    // Draw the heatmap initially
                    updateHeatmap();

                    // Event listeners for filter interactions
                    document.querySelectorAll('#heatmap-formation-options input').forEach(checkbox => {
                        checkbox.addEventListener('change', updateHeatmap);
                    });
                    document.querySelectorAll('#heatmap-oppformation-options input').forEach(checkbox => {
                        checkbox.addEventListener('change', updateHeatmap);
                    });
                    d3.select("#heatmap-order").on("change", updateHeatmap);

                    // Functions to control heatmap rendering
                    function updateHeatmap() {
                        const selectedFormations = Array.from(document.querySelectorAll('#heatmap-formation-options input:checked'))
                            .map(input => input.value);
                        const selectedOppFormations = Array.from(document.querySelectorAll('#heatmap-oppformation-options input:checked'))
                            .map(input => input.value);

                        const filteredData = formationOppData.filter(d =>
                            selectedFormations.includes(d.formation) &&
                            selectedOppFormations.includes(d.oppFormation)
                        );

                        d3.select("#heatmap-no-data").classed("hidden", filteredData.length > 0);
                        reorderHeatmap(filteredData);
                        drawHeatmap(filteredData);
                        drawLegend(); // Draw or update the legend
                    }

                    function reorderHeatmap(data) {
                        const orderOption = document.getElementById('heatmap-order').value;
                        formations = Array.from(new Set(data.map(d => d.formation)));
                        oppFormations = Array.from(new Set(data.map(d => d.oppFormation)));

                        if (orderOption === "name") {
                            formations.sort(d3.ascending);
                            oppFormations.sort(d3.ascending);
                        } else if (orderOption === "cellWinPercentage") {
                            data.sort((a, b) => d3.descending(a.winPercentage, b.winPercentage));
                            formations = Array.from(new Set(data.map(d => d.formation)));
                            oppFormations = Array.from(new Set(data.map(d => d.oppFormation)));
                        }

                        xScale.domain(formations);
                        yScale.domain(oppFormations);

                        xAxisGroup.call(d3.axisBottom(xScale)).selectAll("text")
                            .attr("transform", "rotate(-45)")
                            .style("text-anchor", "end");
                        yAxisGroup.call(d3.axisLeft(yScale));

                        // Remove previous axis labels to prevent duplication
                        svg.selectAll(".axis-label").remove();

                        // Add x-axis label
                        svg.append("text")
                            .attr("class", "axis-label")
                            .attr("text-anchor", "middle")
                            .attr("x", width / 2)
                            .attr("y", height + margin.bottom - 80)
                            .text("Formations");

                        // Add y-axis label
                        svg.append("text")
                            .attr("class", "axis-label")
                            .attr("text-anchor", "middle")
                            .attr("transform", "rotate(-90)")
                            .attr("x", -height / 2)
                            .attr("y", -margin.left + 70)
                            .text("Opponent Formations");
                    }

                    function drawHeatmap(filteredData) {
                        const cells = svg.selectAll("rect.cell").data(filteredData, d => d.formation + ':' + d.oppFormation);

                        cells.enter().append("rect")
                            .attr("class", "cell")
                            .attr("x", d => xScale(d.formation))
                            .attr("y", d => yScale(d.oppFormation))
                            .attr("width", xScale.bandwidth())
                            .attr("height", yScale.bandwidth())
                            .style("fill", d => colorScale(d.winPercentage))
                            .on("mouseover", (event, d) => {
                                heatmapTooltip.style("display", "block")
                                    .style("opacity", 1)
                                    .style("left", `${event.pageX + 15}px`)
                                    .style("top", `${event.pageY - 15}px`)
                                    .html(`
                                        <strong>Formation:</strong> ${d.formation}<br>
                                        <strong>Opponent Formation:</strong> ${d.oppFormation}<br>
                                        <strong>Win %:</strong> ${d.winPercentage.toFixed(2)}%
                                    `);
                            })
                            .on("mouseout", () => heatmapTooltip.style("display", "none").style("opacity", 0));

                        cells.transition().duration(500)
                            .attr("x", d => xScale(d.formation))
                            .attr("y", d => yScale(d.oppFormation))
                            .style("fill", d => colorScale(d.winPercentage));

                        cells.exit().remove();
                    }

                    function drawLegend() {
                        // Remove any existing legend elements
                        legendGroup.selectAll("*").remove();

                        // Define legend scale
                        const legendScale = d3.scaleLinear()
                            .domain(colorScale.domain())
                            .range([legendHeight, 0]);

                        // Define legend axis
                        const legendAxis = d3.axisRight(legendScale)
                            .ticks(5)
                            .tickFormat(d => d + "%");

                        const defs = svg.append("defs");

                        // Append a linearGradient element to the defs and give it a unique id
                        const linearGradient = defs.append("linearGradient")
                            .attr("id", "linear-gradient");

                        // Horizontal gradient (for legend)
                        linearGradient
                            .attr("x1", "0%")
                            .attr("y1", "100%")
                            .attr("x2", "0%")
                            .attr("y2", "0%");

                        // Set the color for the start (0%)
                        linearGradient.append("stop")
                            .attr("offset", "0%")
                            .attr("stop-color", colorScale(0)); // Start color

                        // Set the color for the end (100%)
                        linearGradient.append("stop")
                            .attr("offset", "100%")
                            .attr("stop-color", colorScale(100)); // End color

                        // Draw the rectangle and fill with gradient
                        legendGroup.append("rect")
                            .attr("width", legendWidth)
                            .attr("height", legendHeight)
                            .style("fill", "url(#linear-gradient)");

                        // Add legend axis
                        legendGroup.append("g")
                            .attr("transform", `translate(${legendWidth}, 0)`)
                            .call(legendAxis);
                    }
                })
                .catch(error => {
                    console.error("Error loading data:", error);
                    d3.select("#heatmap-no-data").text("Error loading data, please try again later.").classed("hidden", false);
                });
        })();
    </script>

    
    <!-- Alluvial Diagram and Line Graph Script with Toggle -->
    <script>
        document.addEventListener('DOMContentLoaded', function () {
            // Toggle Event for Switching between Alluvial Diagram and Line Graph
            const graphToggle = document.getElementById('graphToggle');
            const toggleLabel = document.getElementById('toggleLabel');
            const alluvialContainer = document.getElementById('alluvialContainer');
            const lineGraphContainer = document.getElementById('lineGraphContainer');
            
            graphToggle.addEventListener('change', function () {
                if (this.checked) {
                    alluvialContainer.style.display = 'none';
                    lineGraphContainer.style.display = 'block';
                    toggleLabel.textContent = 'Line Graph';
                } else {
                    alluvialContainer.style.display = 'block';
                    lineGraphContainer.style.display = 'none';
                    toggleLabel.textContent = 'Alluvial Diagram';
                }
            });
    
            /* Alluvial Diagram Initialization Code */
            (function () { 
                const margin = { top: 15, right: 30, bottom: 15, left: 30 },
                    width = 1350 - margin.left - margin.right,
                    height = 800 - margin.top - margin.bottom;

                const svg = d3.select("#chart").append("svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", `translate(${margin.left}, ${margin.top})`);

                const color = d3.scaleOrdinal(d3.schemeCategory10);
                const tooltip = d3.select("#fifa-tooltip");

                // Premier League teams list for filtering
                const premierLeagueTeams = new Set([
                    'Arsenal FC', 'Aston Villa', 'Birmingham City', 'Blackburn Rovers', 'Blackpool FC',
                    'Bolton Wanderers', 'AFC Bournemouth', 'Brentford FC', 'Brighton & Hove Albion', 'Burnley FC',
                    'Cardiff City', 'Chelsea FC', 'Crystal Palace', 'Derby County', 'Everton FC', 'Fulham FC',
                    'Huddersfield Town', 'Hull City', 'Leeds United', 'Leicester City', 'Liverpool FC',
                    'Luton Town', 'Manchester City', 'Manchester United', 'Middlesbrough FC', 'Newcastle United',
                    'Norwich City', 'Nottingham Forest', 'Portsmouth FC', 'Queens Park Rangers', 'Reading FC',
                    'Sheffield United', 'Southampton FC', 'Stoke City', 'Sunderland AFC', 'Swansea City',
                    'Tottenham Hotspur', 'Watford FC', 'West Bromwich Albion', 'West Ham United', 'Wigan Athletic',
                    'Wolverhampton Wanderers'
                ]);

                // Update chart based on selected season
                function updateAlluvialChart(season) {
                    svg.selectAll("*").remove();  // Clear SVG content

                    d3.csv("https://raw.githubusercontent.com/SarangAnilkumar/Data_Visualisation/refs/heads/main/premier_league_transfers_all_seasons_with_transfers.csv").then(data => {
                        const filteredData = data.filter(d => d.Season === season);
                        const nodes = [];
                        const links = [];
                        const nodeMap = new Map();
                        let nodeIndex = 0;

                        const otherClubsSourceNode = "Other Clubs (Source)";
                        const otherClubsTargetNode = "Other Clubs (Target)";
                        nodes.push({ name: otherClubsSourceNode, club: otherClubsSourceNode });
                        nodes.push({ name: otherClubsTargetNode, club: otherClubsTargetNode });
                        nodeMap.set(otherClubsSourceNode, nodeIndex++);
                        nodeMap.set(otherClubsTargetNode, nodeIndex++);

                        const summerTransferNode = "Summer Transfer";
                        const winterTransferNode = "Winter Transfer";
                        nodes.push({ name: summerTransferNode, club: summerTransferNode });
                        nodes.push({ name: winterTransferNode, club: winterTransferNode });
                        nodeMap.set(summerTransferNode, nodeIndex++);
                        nodeMap.set(winterTransferNode, nodeIndex++);

                        function addNodeIfNotExists(name) {
                            if (!nodeMap.has(name)) {
                                nodes.push({ name: name, club: name });
                                nodeMap.set(name, nodeIndex++);
                            }
                        }

                        let transferIDCounter = 0;

                        filteredData.forEach(transfer => {
                            const transferID = transferIDCounter++;
                            let sourceClub, targetClub, transferNode;

                            if (transfer["In/Out"] === "In") {
                                sourceClub = transfer["Left/Joined"] + "_source";
                                targetClub = transfer.Club + "_target";
                                transferNode = transfer["Transfer Period"] === "Summer" ? summerTransferNode : winterTransferNode;
                            } else if (transfer["In/Out"] === "Out") {
                                sourceClub = transfer.Club + "_source";
                                targetClub = transfer["Left/Joined"] + "_target";
                                transferNode = transfer["Transfer Period"] === "Summer" ? summerTransferNode : winterTransferNode;
                            }

                            if (!premierLeagueTeams.has(sourceClub.replace("_source", ""))) {
                                sourceClub = otherClubsSourceNode;
                            }
                            if (!premierLeagueTeams.has(targetClub.replace("_target", ""))) {
                                targetClub = otherClubsTargetNode;
                            }

                            addNodeIfNotExists(sourceClub);
                            addNodeIfNotExists(targetClub);

                            links.push({
                                source: nodeMap.get(sourceClub),
                                target: nodeMap.get(transferNode),
                                value: 1,
                                transferID: transferID,
                                player: transfer.Player,
                                age: transfer.Age,
                                nationality: transfer.Nationality,
                                position: transfer.Position,
                                actualSourceClub: transfer["Left/Joined"],
                                actualTargetClub: transfer.Club,
                                imageURL: transfer["Player Image URL"]
                            });

                            links.push({
                                source: nodeMap.get(transferNode),
                                target: nodeMap.get(targetClub),
                                value: 1,
                                transferID: transferID,
                                player: transfer.Player,
                                age: transfer.Age,
                                nationality: transfer.Nationality,
                                position: transfer.Position,
                                actualSourceClub: transfer["Left/Joined"],
                                actualTargetClub: transfer.Club,
                                imageURL: transfer["Player Image URL"]
                            });
                        });

                        const sankey = d3.sankey()
                            .nodeWidth(25)
                            .nodePadding(10)
                            .extent([[1, 1], [width - 1, height - 1]]);

                        const graph = { nodes, links };
                        sankey(graph);

                        const link = svg.append("g")
                            .selectAll("path")
                            .data(graph.links)
                            .join("path")
                            .attr("class", "link")
                            .attr("d", d3.sankeyLinkHorizontal())
                            .attr("stroke-width", d => Math.max(1, d.width))
                            .style("stroke", d => color(d.source.club))
                            .style("fill", "none")
                            .style("stroke-opacity", 0.5)
                            .each(function(d) {
                                const totalLength = this.getTotalLength();
                                const delayTime = d.source.club === "Summer Transfer" || d.source.club === "Winter Transfer" ? 3000 : 0;

                                d3.select(this)
                                    .attr("stroke-dasharray", `${totalLength} ${totalLength}`)
                                    .attr("stroke-dashoffset", totalLength)
                                    .transition()
                                    .delay(delayTime)
                                    .duration(3000)
                                    .ease(d3.easeLinear)
                                    .attr("stroke-dashoffset", 0);
                            });

                        const node = svg.append("g")
                            .selectAll("rect")
                            .data(graph.nodes)
                            .join("rect")
                            .attr("x", d => d.x0)
                            .attr("y", d => d.y0)
                            .attr("height", d => d.y1 - d.y0 + 5)
                            .attr("width", sankey.nodeWidth())
                            .style("fill", d => color(d.club))
                            .style("fill-opacity", 0.85);

                        svg.append("g")
                            .selectAll("text")
                            .data(graph.nodes)
                            .join("text")
                            .attr("x", d => (d.x0 + d.x1) / 2)
                            .attr("y", d => (d.y0 + d.y1) / 2)
                            .attr("dy", "0.35em")
                            .attr("text-anchor", "middle")
                            .attr("font-size", "10px")
                            .text(d => d.club.replace("_source", "").replace("_target", ""));

                        // Ensure the tooltip positioning and visibility on mouseover
                        link.on("mouseover", function(event, d) {
                            svg.selectAll(".link")
                                .style("stroke-opacity", l => l.transferID === d.transferID ? 1 : 0.1)
                                .style("stroke-width", l => l.transferID === d.transferID ? Math.max(4, l.width * 1.5) : l.width)
                                .style("stroke", l => l.transferID === d.transferID ? "gold" : color(l.source.club));

                            node.style("fill-opacity", n => {
                                return (n === d.source || n === d.target || n.name === d.source.name || n.name === d.target.name) ? 1 : 0.5;
                            });

                            // Set tooltip content
                            d3.select("#tooltip-name").text(d.player);
                            d3.select("#tooltip-age").text(d.age);
                            d3.select("#tooltip-nationality").text(d.nationality);
                            d3.select("#tooltip-position").text(d.position);
                            if (d.imageURL) {
                                d3.select("#tooltip-player-image").attr("src", d.imageURL);
                            }

                            // Position and show tooltip
                            tooltip
                                .style("left", `${event.pageX + 15}px`)
                                .style("top", `${event.pageY - 15}px`)
                                .classed("visible", true);  // Show tooltip
                        })
                        .on("mouseout", function() {
                            // Reset styles and hide tooltip on mouseout
                            svg.selectAll(".link")
                                .style("stroke-opacity", 0.5)
                                .style("stroke-width", l => l.width)
                                .style("stroke", l => color(l.source.club));
                            node.style("fill-opacity", 0.85);
                            tooltip.classed("visible", false);  // Hide tooltip
                        });

                    });
                }

                function populateSeasons(data) {
                    const seasonSelect = document.getElementById("alluvial-season-select");
                    seasonSelect.innerHTML = '';
                    const seasons = [...new Set(data.map(d => d.Season))];

                    seasons.forEach(season => {
                        const option = document.createElement("option");
                        option.value = season;
                        option.text = season;
                        seasonSelect.appendChild(option);
                    });
                }

                d3.csv("https://raw.githubusercontent.com/SarangAnilkumar/Data_Visualisation/refs/heads/main/premier_league_transfers_all_seasons_with_transfers.csv")
                    .then(data => {
                        populateSeasons(data);
                        const defaultSeason = data[0].Season;
                        document.getElementById("alluvial-season-select").value = defaultSeason;
                        updateAlluvialChart(defaultSeason);
                    });

                document.getElementById("alluvial-season-select").addEventListener("change", function() {
                    const selectedSeason = this.value;
                    updateAlluvialChart(selectedSeason);
                });
            })();

            /* Line Graph Initialization Code */
            (function () {
                
                // Set dimensions and margins for the Line Chart
                const marginLine = { top: 20, right: 150, bottom: 80, left: 80 },
                    widthLine = 900 - marginLine.left - marginLine.right,
                    heightLine = 500 - marginLine.top - marginLine.bottom;

                // Append SVG object to the page
                const svgLine = d3.select("#line-chart-svg")
                    .attr("width", widthLine + marginLine.left + marginLine.right)
                    .attr("height", heightLine + marginLine.top + marginLine.bottom)
                    .append("g")
                    .attr("transform", `translate(${marginLine.left},${marginLine.top})`);

                // Initialize tooltip
                const tooltipLine = d3.select("#line-chart-tooltip");

                // Color scale for lines
                const colorLine = d3.scaleOrdinal(d3.schemeCategory10);

                // Load football_stats.csv
                d3.csv("https://raw.githubusercontent.com/SarangAnilkumar/Data_Visualisation/main/football_stats.csv").then(function (data) {
                    // Data Processing
                    data.forEach(d => {
                        d.Date = new Date(d.Date);
                        d.Season = d.Season.trim();
                        d.Team = d.Team.trim();
                        d.Result = d.Result.toUpperCase();
                    });

                    // Extract unique seasons
                    const seasons = Array.from(new Set(data.map(d => d.Season))).sort();

                    // Populate Season Dropdown
                    const seasonSelect = d3.select("#lineSeasonSelect");
                    seasons.forEach(season => {
                        seasonSelect.append("option")
                            .attr("value", season)
                            .text(season);
                    });

                    // Set default selection to 2023-2024 season or the latest season if 2023-2024 doesn't exist
                    const defaultSeason = seasons.includes("2023-2024") ? "2023-2024" : seasons[seasons.length - 1];
                    seasonSelect.property("value", defaultSeason);

                    // Initialize team dropdown
                    const teamDropdown = document.getElementById("teamDropdown");
                    const teamDropdownButton = document.getElementById("teamSelectButton");
                    const teamDropdownContent = document.getElementById("teamDropdownContent");

                    // Function to update team dropdown based on selected season
                    function updateTeamDropdown(selectedSeason) {
                        const teamsInSeason = Array.from(new Set(data.filter(d => d.Season === selectedSeason).map(d => d.Team))).sort();

                        teamDropdownContent.innerHTML = ''; // Clear existing options

                        teamsInSeason.forEach(team => {
                            const label = document.createElement("label");
                            const checkbox = document.createElement("input");
                            checkbox.type = "checkbox";
                            checkbox.value = team;
                            label.appendChild(checkbox);
                            label.appendChild(document.createTextNode(" " + team));
                            teamDropdownContent.appendChild(label);
                        });

                        // Select Arsenal FC and Manchester United by default if they exist in the season
                        const defaultTeams = ["Arsenal FC", "Manchester United"];
                        const checkboxes = teamDropdownContent.querySelectorAll('input[type="checkbox"]');
                        checkboxes.forEach(checkbox => {
                            if (defaultTeams.includes(checkbox.value)) {
                                checkbox.checked = true;
                            }
                        });

                        updateTeamSelectButtonText();
                    }

                    // Update the button text based on selected teams
                    function updateTeamSelectButtonText() {
                        const selectedTeams = getSelectedTeams();
                        if (selectedTeams.length > 0) {
                            teamDropdownButton.textContent = selectedTeams.join(', ');
                        } else {
                            teamDropdownButton.textContent = 'Select Teams';
                        }
                    }

                    // Get selected teams
                    function getSelectedTeams() {
                        const checkboxes = teamDropdownContent.querySelectorAll('input[type="checkbox"]:checked');
                        return Array.from(checkboxes).map(cb => cb.value);
                    }

                    // Event listener for team selection
                    teamDropdownContent.addEventListener('change', function (event) {
                        const selectedTeams = getSelectedTeams();
                        if (selectedTeams.length > 2) {
                            alert("Please select up to 2 teams.");
                            event.target.checked = false; // Deselect the last selected checkbox
                        }
                        updateTeamSelectButtonText();
                        updateChart();
                    });

                    // Toggle dropdown visibility
                    teamDropdownButton.addEventListener('click', function (event) {
                        event.stopPropagation();  // Prevent the event from bubbling up
                        toggleDropdown(teamDropdown);
                    });

                    // Close the dropdown if clicked outside
                    document.addEventListener('click', function (event) {
                        if (!event.target.closest('.dropdown-multiselect')) {
                            closeOtherDropdowns(null); // Close all if clicking outside
                        }
                    });

                    // Close other dropdowns
                    function closeOtherDropdowns(currentDropdown) {
                        const dropdowns = document.querySelectorAll('.dropdown-multiselect');
                        dropdowns.forEach(function (dropdown) {
                            if (dropdown !== currentDropdown) {
                                dropdown.classList.remove('active');
                                const content = dropdown.querySelector('.dropdown-multiselect-content');
                                if (content) content.style.display = 'none';
                            }
                        });
                    }

                    // Toggle dropdown
                    function toggleDropdown(dropdown) {
                        const content = dropdown.querySelector('.dropdown-multiselect-content');
                        closeOtherDropdowns(dropdown); // Close other dropdowns
                        dropdown.classList.toggle("active");
                        content.style.display = dropdown.classList.contains("active") ? "block" : "none";
                    }

                    // Event listener for season change
                    seasonSelect.on("change", function () {
                        updateTeamDropdown(this.value);
                        updateChart();
                    });

                    // Initial team dropdown population
                    updateTeamDropdown(defaultSeason);

                    // Initial chart rendering
                    updateChart();

                    // Function to update the chart based on selected filters
                    function updateChart() {
                        const selectedSeason = seasonSelect.property("value");
                        const selectedTeams = getSelectedTeams();

                        // Filter data based on selected season and teams
                        let filteredData = data.filter(d => d.Season === selectedSeason);
                        if (selectedTeams.length > 0) {
                            filteredData = filteredData.filter(d => selectedTeams.includes(d.Team));
                        }

                        // Group data by Team and then by Month
                        const dataByTeamMonth = d3.group(filteredData, d => d.Team, d => d3.timeMonth(d.Date));
                        const lineChartData = [];
                        dataByTeamMonth.forEach((months, team) => {
                            months.forEach((matches, month) => {
                                const totalMatches = matches.length;
                                const wins = matches.filter(m => m.Result === 'W').length;
                                const winPercentage = (wins / totalMatches) * 100;
                                lineChartData.push({ Team: team, Month: month, WinPercentage: winPercentage });
                            });
                        });

                        // Nest data by team for line generation
                        const nestedData = Array.from(d3.group(lineChartData, d => d.Team), ([key, values]) => ({ key, values }));

                        // Set color domain based on selected teams
                        colorLine.domain(nestedData.map(d => d.key));

                        // Define X and Y scales
                        const x = d3.scaleTime()
                            .domain(d3.extent(lineChartData, d => d.Month))
                            .range([0, widthLine]);

                        const maxWinPercentage = d3.max(lineChartData, d => d.WinPercentage);
                        const y = d3.scaleLinear()
                            .domain([0, maxWinPercentage > 0 ? maxWinPercentage * 1.05 : 1])
                            .range([heightLine, 0]);

                        // Remove previous axes, lines, points, and transfer lines
                        svgLine.selectAll(".axis").remove();
                        svgLine.selectAll(".line").remove();
                        svgLine.selectAll(".dot").remove();
                        svgLine.selectAll(".legend").remove();
                        svgLine.selectAll(".transfer-line").remove();
                        svgLine.selectAll(".axis-label").remove();

                        // Add X axis
                        svgLine.append("g")
                            .attr("class", "axis x-axis")
                            .attr("transform", `translate(0,${heightLine})`)
                            .call(d3.axisBottom(x).tickFormat(d3.timeFormat("%b %Y")))
                            .selectAll("text")
                            .attr("transform", "rotate(-45)")
                            .style("text-anchor", "end");

                        // X-axis label
                        svgLine.append("text")
                            .attr("class", "axis-label")
                            .attr("x", widthLine / 2)
                            .attr("y", heightLine + marginLine.bottom - 20)
                            .attr("text-anchor", "middle")
                            .text("Month");

                        // Add Y axis
                        svgLine.append("g")
                            .attr("class", "axis y-axis")
                            .call(d3.axisLeft(y));

                        // Y-axis label
                        svgLine.append("text")
                            .attr("class", "axis-label")
                            .attr("x", -heightLine / 2)
                            .attr("y", -marginLine.left + 20)
                            .attr("transform", "rotate(-90)")
                            .attr("text-anchor", "middle")
                            .text("Win Percentage (%)");

                        // Add transfer window lines and labels
                        const dateRange = x.domain();
                        const transferDates = [];
                        for (let year = dateRange[0].getFullYear(); year <= dateRange[1].getFullYear(); year++) {
                            transferDates.push({ date: new Date(year, 7, 31), type: 'Summer' }); // August 31st
                            transferDates.push({ date: new Date(year, 0, 31), type: 'Winter' }); // January 31st
                        }

                        const transferLines = svgLine.selectAll(".transfer-line")
                            .data(transferDates.filter(d => d.date >= dateRange[0] && d.date <= dateRange[1]))
                            .enter()
                            .append("g")
                            .attr("class", "transfer-line");

                        transferLines.append("line")
                            .attr("x1", d => x(d.date))
                            .attr("x2", d => x(d.date))
                            .attr("y1", 0)
                            .attr("y2", heightLine)
                            .attr("stroke", d => d.type === 'Summer' ? 'orange' : 'blue')
                            .attr("stroke-width", 1)
                            .attr("stroke-dasharray", "5,5");

                        transferLines.append("text")
                            .attr("x", d => x(d.date))
                            .attr("y", 0)
                            .attr("transform", d => `rotate(-90, ${x(d.date)}, 0)`)
                            .attr("dy", -5)
                            .attr("text-anchor", "end")
                            .attr("fill", d => d.type === 'Summer' ? 'orange' : 'blue')
                            .attr("font-size", "10px")
                            .text(d => `${d.type} Transfer Closes`);

                        // Draw lines
                        const line = d3.line()
                            .x(d => x(d.Month))
                            .y(d => y(d.WinPercentage));

                        svgLine.selectAll(".line")
                            .data(nestedData)
                            .enter()
                            .append("path")
                            .attr("class", "line")
                            .attr("d", d => line(d.values))
                            .attr("stroke", d => colorLine(d.key))
                            .attr("stroke-width", 2)
                            .attr("fill", "none")
                            .on("mouseover", function (event, d) {
                                d3.select(this)
                                    .attr("stroke-width", 4);
                            })
                            .on("mouseout", function (event, d) {
                                d3.select(this)
                                    .attr("stroke-width", 2);
                            });

                        // Draw points
                        svgLine.selectAll(".dot")
                            .data(lineChartData)
                            .enter()
                            .append("circle")
                            .attr("class", "dot")
                            .attr("cx", d => x(d.Month))
                            .attr("cy", d => y(d.WinPercentage))
                            .attr("r", 4)
                            .attr("fill", d => colorLine(d.Team))
                            .attr("stroke", "#fff")
                            .attr("stroke-width", 1.5)
                            .on("mouseover", function (event, d) {
                                const formattedWinPercentage = d.WinPercentage.toFixed(2);
                                tooltipLine.html(`
                                    <strong>Team:</strong> ${d.Team}<br>
                                    <strong>Month:</strong> ${d3.timeFormat("%B %Y")(d.Month)}<br>
                                    <strong>Win Percentage:</strong> ${formattedWinPercentage}%
                                `)
                                    .style("left", `${event.pageX + 15}px`)
                                    .style("top", `${event.pageY - 28}px`)
                                    .style("opacity", 1)
                                    .style("display", "block");
                            })
                            .on("mouseout", function () {
                                tooltipLine.style("opacity", 0).style("display", "none");
                            });

                        // Add Legend
                        if (selectedTeams.length > 0) {
                            const legend = svgLine.append("g")
                                .attr("class", "legend")
                                .attr("transform", `translate(${widthLine + 20}, 0)`);

                            nestedData.forEach((d, i) => {
                                const legendRow = legend.append("g")
                                    .attr("transform", `translate(0, ${i * 20})`);

                                legendRow.append("rect")
                                    .attr("width", 12)
                                    .attr("height", 12)
                                    .attr("fill", colorLine(d.key));

                                legendRow.append("text")
                                    .attr("x", 18)
                                    .attr("y", 10)
                                    .text(d.key)
                                    .attr("text-anchor", "start")
                                    .style("font-size", "12px");
                            });
                        }
                    }
                }).catch(function (error) {
                    console.error("Error loading the data: ", error);
                });
            })();

        });
    </script>

    <!-- JavaScript for Scatter Plot Initialization -->
    <script>
        (function() {
            // Define margins and dimensions
            const scatterPlotMargin = { top: 20, right: 20, bottom: 80, left: 80 };
            const scatterPlotWidth = 960 - scatterPlotMargin.left - scatterPlotMargin.right;
            const scatterPlotHeight = 500 - scatterPlotMargin.top - scatterPlotMargin.bottom;
            let scatterPlotCurrentMode = "mode1"; // Default to mode 1
    
            // Create SVG container
            const scatterPlotSvgElement = d3.select("#scatterPlotSVG")
                .attr("width", scatterPlotWidth + scatterPlotMargin.left + scatterPlotMargin.right)
                .attr("height", scatterPlotHeight + scatterPlotMargin.top + scatterPlotMargin.bottom);
    
            const scatterPlotSvg = scatterPlotSvgElement.append("g")
                .attr("transform", `translate(${scatterPlotMargin.left},${scatterPlotMargin.top})`);
    
            // Define clip path
            scatterPlotSvg.append("defs").append("clipPath")
                .attr("id", "scatterPlotClip")
                .append("rect")
                .attr("width", scatterPlotWidth)
                .attr("height", scatterPlotHeight);
    
            // Create a group for data elements and apply the clip path
            const scatterPlotDataGroup = scatterPlotSvg.append("g")
                .attr("class", "scatterPlot-dataGroup")
                .attr("clip-path", "url(#scatterPlotClip)");
    
            const scatterPlotTooltip = d3.select("#scatterPlotTooltip");
    
            // Declare global variables
            let scatterPlotX, scatterPlotY;
            let xAxis, yAxis;
            let scatterPlotXAxis, scatterPlotYAxis;
    
            // Function to parse and clean the transfer fee data
            function scatterPlotCleanFee(fee) {
                fee = fee.trim();
                if (fee.includes("Loan fee:")) {
                    fee = fee.replace("Loan fee:", "").trim();
                }
                if (fee.includes("€")) {
                    fee = fee.replace(/€|,/g, "").trim(); // Remove € and commas
                }
                if (fee.includes("m")) {
                    return parseFloat(fee.replace("m", "")) * 1e6;
                } else if (fee.includes("k")) {
                    return parseFloat(fee.replace("k", "")) * 1e3;
                }
                return 0; // For "free" or unlisted fees
            }
    
            // Function to parse and clean the market value data
            function scatterPlotCleanMarketValue(value) {
                value = value.trim();
                if (value.includes("€")) {
                    value = value.replace(/€|,/g, "").trim(); // Remove € and commas
                }
                if (value.includes("m")) {
                    return parseFloat(value.replace("m", "")) * 1e6;
                } else if (value.includes("k")) {
                    return parseFloat(value.replace("k", "")) * 1e3;
                }
                return 0; // For "unknown" or unlisted values
            }
    
            // Function to calculate linear regression coefficients
            function scatterPlotLeastSquares(xSeries, ySeries) {
                const n = xSeries.length;
                const xMean = d3.mean(xSeries);
                const yMean = d3.mean(ySeries);
                const SSxy = d3.sum(xSeries.map((d, i) => (d - xMean) * (ySeries[i] - yMean)));
                const SSxx = d3.sum(xSeries.map(d => Math.pow(d - xMean, 2)));
                const slope = SSxy / SSxx;
                const intercept = yMean - (slope * xMean);
                return { slope, intercept };
            }
    
            // Function to format numbers in millions
            function formatMillions(value) {
                return (value / 1e6).toFixed(1) + 'M';
            }
    
            // Function to create valid CSS class names from team names
            function makeValidClassName(name) {
                return name.replace(/[^a-zA-Z0-9_-]/g, '_');
            }

            function initializeScatterPlotModal() {
                const modal = document.getElementById("scatterPlotModal");
                const closeButton = modal.querySelector(".close-button");
                const prevSlideButton = document.getElementById("prevSlideButton");
                const nextSlideButton = document.getElementById("nextSlideButton");
                const slides = modal.querySelectorAll(".slide");
                let currentSlide = 0;

                function showSlide(index) {
                    slides.forEach((slide, i) => {
                        slide.classList.toggle("active", i === index);
                    });
                    currentSlide = index;
                    prevSlideButton.style.display = currentSlide === 0 ? "none" : "inline-block";
                    nextSlideButton.style.display = currentSlide === slides.length - 1 ? "none" : "inline-block";
                }

                prevSlideButton.addEventListener("click", () => {
                    if (currentSlide > 0) {
                        showSlide(currentSlide - 1);
                    }
                });

                nextSlideButton.addEventListener("click", () => {
                    if (currentSlide < slides.length - 1) {
                        showSlide(currentSlide + 1);
                    }
                });

                closeButton.addEventListener("click", () => {
                    modal.style.display = "none";
                });

                window.addEventListener("click", (event) => {
                    if (event.target === modal) {
                        modal.style.display = "none";
                    }
                });

                return {
                    showModal: function () {
                        modal.style.display = "block";
                        showSlide(0);
                    },
                    populateContent: function (team, season, transfersIn, transfersOut) {
                        // Populate Transfers In Content
                        const transfersInContent = document.getElementById("transfersInContent");
                        transfersInContent.innerHTML = generateTransfersTable(transfersIn);

                        // Populate Transfers Out Content
                        const transfersOutContent = document.getElementById("transfersOutContent");
                        transfersOutContent.innerHTML = generateTransfersTable(transfersOut);
                    }
                };
            }

            function generateTransfersTable(transfers) {
                if (transfers.length === 0) {
                    return "<p>No data available.</p>";
                }

                let tableHTML = "<table>";
                tableHTML += "<tr><th>Player</th><th>Market Value (€)</th><th>Fee (€)</th></tr>";
                transfers.forEach(transfer => {
                    tableHTML += `<tr>
                    <td>${transfer.Player}</td>
                    <td>${transfer["Market Value"]}</td>
                    <td>${transfer.Fee}</td>
                </tr>`;
                });
                tableHTML += "</table>";
                return tableHTML;
            }

            // Initialize the modal
            const scatterPlotModal = initializeScatterPlotModal();
    
            // Load data and initialize filters
            Promise.all([
                d3.csv("https://raw.githubusercontent.com/SarangAnilkumar/Data_Visualisation/main/football_stats.csv"),
                d3.csv("https://raw.githubusercontent.com/SarangAnilkumar/Data_Visualisation/main/premier_league_transfers_all_seasons_with_transfers.csv")
            ]).then(([footballData, transferData]) => {
    
                // Parse and clean data
                footballData.forEach(d => {
                    d.Date = new Date(d.Date);
                    d.Season = d.Season.trim();
                    d.Team = d.Team.trim();
                    d.Result = d.Result.toUpperCase();
                });
    
                transferData.forEach(d => {
                    d.Season = d.Season.trim();
                    d.Club = d.Club.trim();
                });
    
                // Calculate win percentage by team and season
                const scatterPlotWinData = d3.rollup(
                    footballData,
                    v => {
                        const totalGames = v.length;
                        const wins = v.filter(d => d.Result === "W").length;
                        return (wins / totalGames) * 100;
                    },
                    d => d.Team,
                    d => d.Season
                );
    
                // Calculate total fees paid and market value by team and season
                const scatterPlotFeeAndValueData = d3.rollup(
                    transferData.filter(d => d["In/Out"] === "In"),  // Only "In" transfers are spending
                    v => {
                        return {
                            totalFeesPaid: d3.sum(v, d => scatterPlotCleanFee(d.Fee)),
                            totalMarketValue: d3.sum(v, d => scatterPlotCleanMarketValue(d["Market Value"]))
                        };
                    },
                    d => d.Club,
                    d => d.Season
                );
    
                const scatterPlotSeasons = [...new Set(footballData.map(d => d.Season))].sort();
                const scatterPlotTeams = [...new Set(transferData.map(d => d.Club))].sort();
    
                // Populate season and team filters
                const scatterPlotSeasonDropdownContent = d3.select("#scatterPlot-seasonDropdown");
                const scatterPlotTeamDropdownContent = d3.select("#scatterPlot-teamDropdownContent");
    
                // Add "(All)" option at the top for seasons
                scatterPlotSeasonDropdownContent.append("label")
                    .html(`<input type="checkbox" id="scatterPlot-seasonAll" value="all" checked> (All)`);
    
                scatterPlotSeasons.forEach(season => {
                    const id = `scatterPlot-season-${season.replace(/\s+/g, '')}`;
                    scatterPlotSeasonDropdownContent.append("label")
                        .html(`<input type="checkbox" id="${id}" value="${season}" checked> ${season}`);
                });
    
                scatterPlotTeams.forEach(team => {
                    const id = `scatterPlot-team-${makeValidClassName(team)}`;
                    // By default select Arsenal FC and Chelsea FC
                    const isChecked = team === "Arsenal FC" || team === "Chelsea FC" ? "checked" : "";
                    scatterPlotTeamDropdownContent.append("label")
                        .html(`<input type="checkbox" id="${id}" value="${team}" ${isChecked}> ${team}`);
                });
    
                // Handle dropdown toggling
                document.querySelectorAll('.scatterPlot-dropdown-multiselect').forEach(dropdown => {
                    const button = dropdown.querySelector('.scatterPlot-dropbtn');
                    const content = dropdown.querySelector('.scatterPlot-dropdown-multiselect-content');
                    if (button && content) {
                        button.addEventListener('click', function (event) {
                            event.stopPropagation(); // Prevent event from bubbling up
                            scatterPlotCloseOtherDropdowns(dropdown);
                            dropdown.classList.toggle('active');
                            content.style.display = dropdown.classList.contains('active') ? 'block' : 'none';
                        });
                    }
                });
    
                // Close dropdowns when clicking outside
                document.addEventListener('click', function (event) {
                    if (!event.target.closest('.scatterPlot-dropdown-multiselect')) {
                        scatterPlotCloseOtherDropdowns(null);
                    }
                });
    
                function scatterPlotCloseOtherDropdowns(currentDropdown) {
                    document.querySelectorAll('.scatterPlot-dropdown-multiselect').forEach(dropdown => {
                        if (dropdown !== currentDropdown) {
                            dropdown.classList.remove('active');
                            const content = dropdown.querySelector('.scatterPlot-dropdown-multiselect-content');
                            if (content) content.style.display = 'none';
                        }
                    });
                }
    
                // Function to get selected seasons
                function getScatterPlotSelectedSeasons() {
                    const checkboxes = document.querySelectorAll('#scatterPlot-seasonDropdown input[type="checkbox"]');
                    const selectedSeasons = [];
                    checkboxes.forEach(cb => {
                        if (cb.checked && cb.value !== 'all') selectedSeasons.push(cb.value);
                    });
                    return selectedSeasons;
                }
    
                // Function to get selected teams
                function getScatterPlotSelectedTeams() {
                    const checkboxes = document.querySelectorAll('#scatterPlot-teamDropdownContent input[type="checkbox"]');
                    const selectedTeams = [];
                    checkboxes.forEach(cb => {
                        if (cb.checked) selectedTeams.push(cb.value);
                    });
                    return selectedTeams;
                }
    
                // Event listener for "(All)" checkbox in seasons
                const scatterPlotSeasonAllCheckbox = document.getElementById('scatterPlot-seasonAll');
                if (scatterPlotSeasonAllCheckbox) {
                    scatterPlotSeasonAllCheckbox.addEventListener('change', function () {
                        const checkboxes = document.querySelectorAll('#scatterPlot-seasonDropdown input[type="checkbox"]');
                        const isChecked = this.checked;
                        checkboxes.forEach(cb => {
                            if (cb !== this) {
                                cb.checked = isChecked;
                            }
                        });
                        if (scatterPlotCurrentMode === "mode1") renderScatterPlotMode1();
                    });
                }
    
                // Event listeners for individual season checkboxes
                document.querySelectorAll('#scatterPlot-seasonDropdown input[type="checkbox"]').forEach(cb => {
                    if (cb.id !== 'scatterPlot-seasonAll') {
                        cb.addEventListener('change', function () {
                            const allCheckbox = document.getElementById('scatterPlot-seasonAll');
                            const checkboxes = document.querySelectorAll('#scatterPlot-seasonDropdown input[type="checkbox"]');
                            const totalCheckboxes = checkboxes.length - 1; // Exclude "(All)" checkbox
                            const checkedCheckboxes = Array.from(checkboxes).filter(cb => cb.checked && cb.id !== 'scatterPlot-seasonAll').length;
    
                            if (checkedCheckboxes === totalCheckboxes) {
                                allCheckbox.checked = true;
                            } else {
                                allCheckbox.checked = false;
                            }
    
                            if (scatterPlotCurrentMode === "mode1") renderScatterPlotMode1();
                        });
                    }
                });
    
                // Attach event listeners to team checkboxes after they are created
                function attachScatterPlotTeamCheckboxListeners() {
                    document.querySelectorAll('#scatterPlot-teamDropdownContent input[type="checkbox"]').forEach(cb => {
                        cb.addEventListener('change', function () {
                            const selectedTeams = getScatterPlotSelectedTeams();
                            if (selectedTeams.length > 2) {
                                this.checked = false;
                                alert("You can select a maximum of 2 teams.");
                            }
                            if (scatterPlotCurrentMode === "mode2") renderScatterPlotMode2();
                        });
                    });
                }
    
                // Call the function to attach listeners
                attachScatterPlotTeamCheckboxListeners();
    
                // Define zoom behavior
                const scatterPlotZoom = d3.zoom()
                    .scaleExtent([0.5, 20]) // Adjust the scale extent as needed
                    .translateExtent([[0, 0], [scatterPlotWidth, scatterPlotHeight]])
                    .on('zoom', scatterPlotZoomed);
    
                // Apply zoom to the SVG element
                scatterPlotSvgElement.call(scatterPlotZoom);
    
                // Function to render Mode 1 chart
                function renderScatterPlotMode1() {
                    // Remove elements from Mode 2
                    scatterPlotDataGroup.selectAll(".mode2").remove();
                    scatterPlotSvg.selectAll(".x-axis.mode2").remove();
                    scatterPlotSvg.selectAll(".y-axis.mode2").remove();
                    scatterPlotSvg.selectAll(".x-label.mode2").remove();
                    scatterPlotSvg.selectAll(".y-label.mode2").remove();
                    scatterPlotSvg.selectAll(".no-data-text").remove();
    
                    const selectedSeasons = getScatterPlotSelectedSeasons();
    
                    // If no seasons are selected, clear Mode 1 elements and display message
                    if (selectedSeasons.length === 0) {
                        scatterPlotDataGroup.selectAll(".mode1").remove();
                        scatterPlotSvg.selectAll(".x-axis.mode1").remove();
                        scatterPlotSvg.selectAll(".y-axis.mode1").remove();
                        scatterPlotSvg.selectAll(".x-label.mode1").remove();
                        scatterPlotSvg.selectAll(".y-label.mode1").remove();
                        d3.select("#scatterPlotLegendContainer").selectAll("*").remove();
    
                        // Display message
                        scatterPlotSvg.append("text")
                            .attr("class", "no-data-text")
                            .attr("x", scatterPlotWidth / 2)
                            .attr("y", scatterPlotHeight / 2)
                            .text("Select details to be displayed")
                            .attr("text-anchor", "middle")
                            .attr("fill", "#555")
                            .style("font-size", "24px");
                        return;
                    } else {
                        scatterPlotSvg.selectAll(".no-data-text").remove();
                    }
    
                    // Aggregate data per team over selected seasons
                    const data = [];
                    for (const team of scatterPlotTeams) {
                        let totalWins = 0;
                        let totalGames = 0;
                        let totalFeesPaid = 0;
                        let totalMarketValue = 0;
    
                        if (scatterPlotWinData.has(team)) {
                            for (const [season, winPercentage] of scatterPlotWinData.get(team)) {
                                if (selectedSeasons.includes(season)) {
                                    const games = footballData.filter(d => d.Team === team && d.Season === season).length;
                                    const wins = Math.round(winPercentage * games / 100);
                                    totalWins += wins;
                                    totalGames += games;
                                }
                            }
                        }
    
                        if (scatterPlotFeeAndValueData.has(team)) {
                            for (const [season, feeValue] of scatterPlotFeeAndValueData.get(team)) {
                                if (selectedSeasons.includes(season)) {
                                    totalFeesPaid += feeValue.totalFeesPaid;
                                    totalMarketValue += feeValue.totalMarketValue;
                                }
                            }
                        }
    
                        if (totalGames > 0 && totalFeesPaid > 0) {
                            const winPercentage = (totalWins / totalGames) * 100;
                            data.push({
                                Team: team,
                                WinPercentage: winPercentage,
                                TotalFeesPaid: totalFeesPaid,
                                TotalMarketValue: totalMarketValue
                            });
                        }
                    }
    
                    // If no data, clear Mode 1 elements and display message
                    if (data.length === 0) {
                        scatterPlotDataGroup.selectAll(".mode1").remove();
                        scatterPlotSvg.selectAll(".x-axis.mode1").remove();
                        scatterPlotSvg.selectAll(".y-axis.mode1").remove();
                        scatterPlotSvg.selectAll(".x-label.mode1").remove();
                        scatterPlotSvg.selectAll(".y-label.mode1").remove();
                        d3.select("#scatterPlotLegendContainer").selectAll("*").remove();
    
                        // Display message
                        scatterPlotSvg.append("text")
                            .attr("class", "no-data-text")
                            .attr("x", scatterPlotWidth / 2)
                            .attr("y", scatterPlotHeight / 2)
                            .text("Select details to be displayed")
                            .attr("text-anchor", "middle")
                            .attr("fill", "#555")
                            .style("font-size", "24px");
                        return;
                    } else {
                        scatterPlotSvg.selectAll(".no-data-text").remove();
                    }
    
                    // Define scales
                    scatterPlotX = d3.scaleLinear()
                        .domain([
                            d3.min(data, d => d.TotalFeesPaid) * 0.95,
                            d3.max(data, d => d.TotalFeesPaid) * 1.05
                        ])
                        .range([0, scatterPlotWidth]);
    
                    scatterPlotY = d3.scaleLinear()
                        .domain([
                            d3.min(data, d => d.WinPercentage) * 0.95,
                            d3.max(data, d => d.WinPercentage) * 1.05
                        ])
                        .range([scatterPlotHeight, 0]);
    
                    // Define radius scale based on TotalMarketValue
                    const rScale = d3.scaleSqrt()
                        .domain([
                            d3.min(data, d => d.TotalMarketValue),
                            d3.max(data, d => d.TotalMarketValue)
                        ])
                        .range([5, 25]); // Adjust the range as needed
    
                    // Define axes with custom tick format
                    xAxis = d3.axisBottom(scatterPlotX).tickFormat(formatMillions);
                    yAxis = d3.axisLeft(scatterPlotY); // Win percentage doesn't need millions format
    
                    // Remove existing axes if any
                    if (scatterPlotXAxis) scatterPlotXAxis.remove();
                    if (scatterPlotYAxis) scatterPlotYAxis.remove();
    
                    // Append axes groups and assign to global variables
                    scatterPlotXAxis = scatterPlotSvg.append("g")
                        .attr("class", "x-axis mode1")
                        .attr("transform", `translate(0,${scatterPlotHeight})`)
                        .call(xAxis);
    
                    scatterPlotYAxis = scatterPlotSvg.append("g")
                        .attr("class", "y-axis mode1")
                        .call(yAxis);
    
                    const colors = [
                        ...d3.schemeCategory10,
                        ...d3.schemeSet2,
                        ...d3.schemePastel1
                    ];
                    // Define color scale for Mode 1
                    const color = d3.scaleOrdinal(colors).domain(scatterPlotTeams);
    
                    // Bind data to Mode 1 nodes
                    const nodes = scatterPlotDataGroup.selectAll(".node.mode1")
                        .data(data, d => d.Team); // Unique key per team
    
                    // Exit selection: Remove nodes that are no longer relevant
                    nodes.exit()
                        .transition()
                        .duration(1000)
                        .style("opacity", 0)
                        .remove();
    
                    // Enter selection: Create new nodes
                    const nodesEnter = nodes.enter().append("g")
                        .attr("class", d => `node mode1 node-${makeValidClassName(d.Team)}`)
                        .style("opacity", 0)
                        .attr("transform", d => `translate(${scatterPlotX(d.TotalFeesPaid)},${scatterPlotY(d.WinPercentage)})`)
                        .each(function(d) {
                            d.xValue = d.TotalFeesPaid;
                            d.yValue = d.WinPercentage;
                        });
    
                    // Append circles to new nodes with variable sizes
                    nodesEnter.append("circle")
                        .attr("r", d => rScale(d.TotalMarketValue)) // Variable radius based on TotalMarketValue
                        .style("fill", d => color(d.Team))
                        .style("opacity", 0.7)
                        .on("mouseover", function(event, d) {
                            scatterPlotTooltip.style("display", "block")
                                .html(`
                                    <strong>Team:</strong> ${d.Team}<br>
                                    <strong>Win Percentage:</strong> ${d.WinPercentage.toFixed(2)}%<br>
                                    <strong>Total Fees Paid:</strong> €${d.TotalFeesPaid.toLocaleString()}<br>
                                    <strong>Total Market Value:</strong> €${d.TotalMarketValue.toLocaleString()}
                                `)
                                .style("left", (event.pageX + 15) + "px")
                                .style("top", (event.pageY - 28) + "px");
                        })
                        .on("mouseout", () => scatterPlotTooltip.style("display", "none"));
    
                    // Append text labels to new nodes
                    nodesEnter.append("text")
                        .attr("dy", ".35em")
                        .attr("y", d => -rScale(d.TotalMarketValue) - 5)
                        .attr("text-anchor", "middle")
                        .text(d => d.Team)
                        .style("font-size", "12px")
                        .style("pointer-events", "none"); // Ensure text doesn't capture mouse events
    
                    // Merge enter and update selections
                    const nodesMerge = nodesEnter.merge(nodes);
    
                    // Apply transitions to merged nodes
                    nodesMerge.transition()
                        .duration(1000)
                        .style("opacity", 1)
                        .attr("transform", d => `translate(${scatterPlotX(d.TotalFeesPaid)},${scatterPlotY(d.WinPercentage)})`)
                        .each(function(d) {
                            d.xValue = d.TotalFeesPaid;
                            d.yValue = d.WinPercentage;
                        });
    
                    // Update circles with variable sizes
                    nodesMerge.select("circle")
                        .transition()
                        .duration(1000)
                        .attr("r", d => rScale(d.TotalMarketValue)) // Variable radius
                        .style("fill", d => color(d.Team));
    
                    // Update text labels
                    nodesMerge.select("text")
                        .transition()
                        .duration(1000)
                        .attr("y", d => -rScale(d.TotalMarketValue) - 5)
                        .text(d => d.Team);
    
                    // Compute and draw trendline
                    const xSeries = data.map(d => d.TotalFeesPaid);
                    const ySeries = data.map(d => d.WinPercentage);
                    const { slope, intercept } = scatterPlotLeastSquares(xSeries, ySeries);

                    // Define trendline points using the full x-axis domain
                    const xMin = scatterPlotX.domain()[0];
                    const xMax = scatterPlotX.domain()[1];
                    const yMin = slope * xMin + intercept;
                    const yMax = slope * xMax + intercept;

                    const trendData = [
                        { x: xMin, y: yMin },
                        { x: xMax, y: yMax }
                    ];

                    // Remove existing trendline
                    scatterPlotDataGroup.selectAll(".trendline.mode1").remove();

                    // Append trendline path
                    scatterPlotDataGroup.append("path")
                        .datum(trendData)
                        .attr("class", "trendline mode1")
                        .attr("d", d3.line()
                            .x(d => scatterPlotX(d.x))
                            .y(d => scatterPlotY(d.y))
                        )
                        .attr("stroke", "black")
                        .attr("stroke-width", 2)
                        .attr("fill", "none")
                        .attr("stroke-dasharray", function() {
                            const totalLength = this.getTotalLength();
                            return `${totalLength} ${totalLength}`;
                        })
                        .attr("stroke-dashoffset", function() {
                            return this.getTotalLength();
                        })
                        .transition()
                        .duration(1000)
                        .attr("stroke-dashoffset", 0);

    
                    // Axis labels for Mode 1
                    scatterPlotSvg.selectAll(".x-label.mode1").remove();
                    scatterPlotSvg.selectAll(".y-label.mode1").remove();
    
                    scatterPlotSvg.append("text")
                        .attr("class", "x-label mode1")
                        .attr("transform", `translate(${scatterPlotWidth / 2}, ${scatterPlotHeight + 60})`)
                        .style("text-anchor", "middle")
                        .text("Total Fees Paid (€)");
    
                    scatterPlotSvg.append("text")
                        .attr("class", "y-label mode1")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -scatterPlotHeight / 2)
                        .attr("y", -60)
                        .style("text-anchor", "middle")
                        .text("Win Percentage (%)");
    
                    // Remove existing legend items
                    d3.select("#scatterPlotLegendContainer").selectAll("*").remove();
    
                    // Add legend for Mode 1
                    const legendContainer = d3.select("#scatterPlotLegendContainer")
                        .attr("class", "legend-container mode1");
    
                    const legendItems = legendContainer.selectAll(".legend-item")
                        .data(data)
                        .enter().append("div")
                        .attr("class", "legend-item")
                        .on("click", function(event, d) {
                            // Remove highlight from all nodes
                            scatterPlotDataGroup.selectAll(".highlighted-node").classed("highlighted-node", false);
                            scatterPlotDataGroup.selectAll(".dimmed-node").classed("dimmed-node", false);
    
                            // Highlight selected node
                            const selectedNode = scatterPlotDataGroup.select(`.node-${makeValidClassName(d.Team)}`);
                            selectedNode.classed("highlighted-node", true);
    
                            // Dim other nodes
                            scatterPlotDataGroup.selectAll(".node.mode1")
                                .filter(nodeData => nodeData.Team !== d.Team)
                                .classed("dimmed-node", true);
                        });
    
                    legendItems.append("svg")
                        .attr("width", 12)
                        .attr("height", 12)
                        .append("rect")
                        .attr("width", 12)
                        .attr("height", 12)
                        .style("fill", d => color(d.Team));
    
                    legendItems.append("span")
                        .text(d => d.Team)
                        .style("font-size", "12px");
                }
    
                // Function to render Mode 2 chart
                function renderScatterPlotMode2() {
                    // Remove elements from Mode 1
                    scatterPlotDataGroup.selectAll(".mode1").remove();
                    scatterPlotSvg.selectAll(".x-axis.mode1").remove();
                    scatterPlotSvg.selectAll(".y-axis.mode1").remove();
                    scatterPlotSvg.selectAll(".x-label.mode1").remove();
                    scatterPlotSvg.selectAll(".y-label.mode1").remove();
                    scatterPlotSvg.selectAll(".no-data-text").remove();
                    d3.select("#scatterPlotLegendContainer").selectAll("*").remove();
    
                    const selectedTeams = getScatterPlotSelectedTeams();
    
                    // If no teams are selected, clear Mode 2 elements and display message
                    if (selectedTeams.length === 0) {
                        scatterPlotDataGroup.selectAll(".mode2").remove();
                        scatterPlotSvg.selectAll(".x-axis.mode2").remove();
                        scatterPlotSvg.selectAll(".y-axis.mode2").remove();
                        scatterPlotSvg.selectAll(".x-label.mode2").remove();
                        scatterPlotSvg.selectAll(".y-label.mode2").remove();
    
                        // Display message
                        scatterPlotSvg.append("text")
                            .attr("class", "no-data-text")
                            .attr("x", scatterPlotWidth / 2)
                            .attr("y", scatterPlotHeight / 2)
                            .text("Select details to be displayed")
                            .attr("text-anchor", "middle")
                            .attr("fill", "#555")
                            .style("font-size", "24px");
                        return;
                    } else {
                        scatterPlotSvg.selectAll(".no-data-text").remove();
                    }
    
                    // Aggregate data for selected teams across all seasons
                    const data = [];
                    selectedTeams.forEach(team => {
                        if (scatterPlotWinData.has(team) && scatterPlotFeeAndValueData.has(team)) {
                            const teamWinData = scatterPlotWinData.get(team); // Map of season -> win percentage
                            const teamFeeValueData = scatterPlotFeeAndValueData.get(team); // Map of season -> {totalFeesPaid, totalMarketValue}
    
                            teamWinData.forEach((winPercentage, season) => {
                                if (teamFeeValueData.has(season)) {
                                    const feeValue = teamFeeValueData.get(season);
                                    data.push({
                                        Team: team,
                                        Season: season,
                                        WinPercentage: winPercentage,
                                        TotalFeesPaid: feeValue.totalFeesPaid,
                                        TotalMarketValue: feeValue.totalMarketValue
                                    });
                                }
                            });
                        }
                    });
    
                    // If no data after aggregation, clear Mode 2 elements and display message
                    if (data.length === 0) {
                        scatterPlotDataGroup.selectAll(".mode2").remove();
                        scatterPlotSvg.selectAll(".x-axis.mode2").remove();
                        scatterPlotSvg.selectAll(".y-axis.mode2").remove();
                        scatterPlotSvg.selectAll(".x-label.mode2").remove();
                        scatterPlotSvg.selectAll(".y-label.mode2").remove();
                        d3.select("#scatterPlotLegendContainer").selectAll("*").remove();
    
                        // Display message
                        scatterPlotSvg.append("text")
                            .attr("class", "no-data-text")
                            .attr("x", scatterPlotWidth / 2)
                            .attr("y", scatterPlotHeight / 2)
                            .text("Select details to be displayed")
                            .attr("text-anchor", "middle")
                            .attr("fill", "#555")
                            .style("font-size", "24px");
                        return;
                    } else {
                        scatterPlotSvg.selectAll(".no-data-text").remove();
                    }
    
                    // Define scales
                    scatterPlotX = d3.scaleLinear()
                        .domain([
                            d3.min(data, d => d.TotalFeesPaid) * 0.95,
                            d3.max(data, d => d.TotalFeesPaid) * 1.05
                        ])
                        .range([0, scatterPlotWidth]);
    
                    scatterPlotY = d3.scaleLinear()
                        .domain([
                            d3.min(data, d => d.WinPercentage) * 0.95,
                            d3.max(data, d => d.WinPercentage) * 1.05
                        ])
                        .range([scatterPlotHeight, 0]);
    
                    // Define radius scale based on TotalMarketValue
                    const rScale = d3.scaleSqrt()
                        .domain([
                            d3.min(data, d => d.TotalMarketValue),
                            d3.max(data, d => d.TotalMarketValue)
                        ])
                        .range([5, 25]); // Adjust the range as needed
    
                    // Define axes with custom tick format
                    xAxis = d3.axisBottom(scatterPlotX).tickFormat(formatMillions);
                    yAxis = d3.axisLeft(scatterPlotY); // Win percentage doesn't need millions format
    
                    // Remove existing axes if any
                    if (scatterPlotXAxis) scatterPlotXAxis.remove();
                    if (scatterPlotYAxis) scatterPlotYAxis.remove();
    
                    // Append axes groups and assign to global variables
                    scatterPlotXAxis = scatterPlotSvg.append("g")
                        .attr("class", "x-axis mode2")
                        .attr("transform", `translate(0,${scatterPlotHeight})`)
                        .call(xAxis);
    
                    scatterPlotYAxis = scatterPlotSvg.append("g")
                        .attr("class", "y-axis mode2")
                        .call(yAxis);
    
                    // Define color scale for selected teams
                    const color = d3.scaleOrdinal(d3.schemeCategory10).domain(selectedTeams);
    
                    // Bind data to Mode 2 nodes
                    const nodes = scatterPlotDataGroup.selectAll(".node.mode2")
                        .data(data, d => d.Team + d.Season); // Unique key per team-season
    
                    // Exit selection: Remove nodes that are no longer relevant
                    nodes.exit()
                        .transition()
                        .duration(1000)
                        .style("opacity", 0)
                        .remove();
    
                    // Enter selection: Create new nodes
                    const nodesEnter = nodes.enter().append("g")
                        .attr("class", d => `node mode2 node-${d.Team.replace(/\s+/g, '')}`)
                        .style("opacity", 0)
                        .attr("transform", d => `translate(${scatterPlotX(d.TotalFeesPaid)},${scatterPlotY(d.WinPercentage)})`)
                        .each(function(d) {
                            d.xValue = d.TotalFeesPaid;
                            d.yValue = d.WinPercentage;
                        });
    
                    // Append circles to new nodes with variable sizes
                    nodesEnter.append("circle")
                        .attr("r", d => rScale(d.TotalMarketValue)) // Variable radius based on TotalMarketValue
                        .style("fill", d => color(d.Team))
                        .style("opacity", 0.7)
                        .on("mouseover", function(event, d) {
                            scatterPlotTooltip.style("display", "block")
                                .html(`
                                    <strong>Team:</strong> ${d.Team}<br>
                                    <strong>Season:</strong> ${d.Season}<br>
                                    <strong>Win Percentage:</strong> ${d.WinPercentage.toFixed(2)}%<br>
                                    <strong>Total Fees Paid:</strong> €${d.TotalFeesPaid.toLocaleString()}<br>
                                    <strong>Total Market Value:</strong> €${d.TotalMarketValue.toLocaleString()}
                                `)
                                .style("left", (event.pageX + 15) + "px")
                                .style("top", (event.pageY - 28) + "px");
                        })
                        .on("mouseout", () => scatterPlotTooltip.style("display", "none"));
    
                    // Append text labels to new nodes
                    nodesEnter.append("text")
                        .attr("dy", ".35em")
                        .attr("y", d => -rScale(d.TotalMarketValue) - 5)
                        .attr("text-anchor", "middle")
                        .text(d => `${d.Team} (${d.Season})`)
                        .style("font-size", "12px")
                        .style("pointer-events", "none"); // Ensure text doesn't capture mouse events
    
                    // Merge enter and update selections
                    const nodesMerge = nodesEnter.merge(nodes);
    
                    // Apply transitions to merged nodes
                    nodesMerge.transition()
                        .duration(1000)
                        .style("opacity", 1)
                        .attr("transform", d => `translate(${scatterPlotX(d.TotalFeesPaid)},${scatterPlotY(d.WinPercentage)})`)
                        .each(function(d) {
                            d.xValue = d.TotalFeesPaid;
                            d.yValue = d.WinPercentage;
                        });
    
                    // Update circles with variable sizes
                    nodesMerge.select("circle")
                        .transition()
                        .duration(1000)
                        .attr("r", d => rScale(d.TotalMarketValue)) // Variable radius
                        .style("fill", d => color(d.Team));
    
                    // Update text labels
                    nodesMerge.select("text")
                        .transition()
                        .duration(1000)
                        .attr("y", d => -rScale(d.TotalMarketValue) - 5)
                        .text(d => `${d.Team} (${d.Season})`);
    
                    // Remove existing trendlines in Mode 2
                    scatterPlotDataGroup.selectAll(".trendline.mode2").remove();
    
                    selectedTeams.forEach(team => {
                        const teamData = data.filter(d => d.Team === team);
                        if (teamData.length < 2) return; // Need at least two points for a trendline

                        const xSeries = teamData.map(d => d.TotalFeesPaid);
                        const ySeries = teamData.map(d => d.WinPercentage);
                        const { slope, intercept } = scatterPlotLeastSquares(xSeries, ySeries);

                        // Define trendline points using the full x-axis domain
                        const xMin = scatterPlotX.domain()[0];
                        const xMax = scatterPlotX.domain()[1];

                        const yMin = slope * xMin + intercept;
                        const yMax = slope * xMax + intercept;

                        const trendData = [
                            { x: xMin, y: yMin },
                            { x: xMax, y: yMax }
                        ];

                        // Append trendline path
                        scatterPlotDataGroup.append("path")
                            .datum(trendData)
                            .attr("class", `trendline mode2 trendline-${team.replace(/\s+/g, '')}`)
                            .attr("d", d3.line()
                                .x(d => scatterPlotX(d.x))
                                .y(d => scatterPlotY(d.y))
                            )
                            .attr("stroke", color(team))
                            .attr("stroke-width", 2)
                            .attr("fill", "none")
                            .attr("stroke-dasharray", function () {
                                const totalLength = this.getTotalLength();
                                return `${totalLength} ${totalLength}`;
                            })
                            .attr("stroke-dashoffset", function () {
                                return this.getTotalLength();
                            })
                            .transition()
                            .duration(1000)
                            .attr("stroke-dashoffset", 0);
                    });

    
                    // Axis labels for Mode 2
                    scatterPlotSvg.selectAll(".x-label.mode2").remove();
                    scatterPlotSvg.selectAll(".y-label.mode2").remove();
    
                    scatterPlotSvg.append("text")
                        .attr("class", "x-label mode2")
                        .attr("transform", `translate(${scatterPlotWidth / 2}, ${scatterPlotHeight + 60})`)
                        .style("text-anchor", "middle")
                        .text("Total Fees Paid (€)");
    
                    scatterPlotSvg.append("text")
                        .attr("class", "y-label mode2")
                        .attr("transform", "rotate(-90)")
                        .attr("x", -scatterPlotHeight / 2)
                        .attr("y", -60)
                        .style("text-anchor", "middle")
                        .text("Win Percentage (%)");
    
                    // Remove existing legend items
                    d3.select("#scatterPlotLegendContainer").selectAll("*").remove();
    
                    // Add legend for Mode 2
                    const legendContainer = d3.select("#scatterPlotLegendContainer")
                        .attr("class", "legend-container mode2");
    
                    const legendItems = legendContainer.selectAll(".legend-item")
                        .data(selectedTeams)
                        .enter().append("div")
                        .attr("class", "legend-item");
    
                    legendItems.append("svg")
                        .attr("width", 12)
                        .attr("height", 12)
                        .append("rect")
                        .attr("width", 12)
                        .attr("height", 12)
                        .style("fill", d => color(d));
    
                    legendItems.append("span")
                        .text(d => d)
                        .style("font-size", "12px");

                    // Add click event listener to nodes in Mode 2
                    nodesMerge.on("click", function(event, d) {
                        const team = d.Team;
                        const season = d.Season;

                        // Get transfers in for the team and season
                        const transfersIn = transferData.filter(transfer =>
                            transfer.Club === team &&
                            transfer.Season === season &&
                            transfer["In/Out"] === "In"
                        );

                        // Get transfers out for the team and season
                        const transfersOut = transferData.filter(transfer =>
                            transfer.Club === team &&
                            transfer.Season === season &&
                            transfer["In/Out"] === "Out"
                        );

                        // Populate the modal content
                        scatterPlotModal.populateContent(team, season, transfersIn, transfersOut);

                        // Show the modal
                        scatterPlotModal.showModal();
                    });

                }
    
                // Zoom function
                function scatterPlotZoomed(event) {
                    const transform = event.transform;
                    const newX = transform.rescaleX(scatterPlotX);
                    const newY = transform.rescaleY(scatterPlotY);

                    // Update axes with new scales and custom tick format
                    scatterPlotXAxis.call(d3.axisBottom(newX).tickFormat(formatMillions));
                    scatterPlotYAxis.call(d3.axisLeft(newY));

                    // Update positions of the nodes
                    scatterPlotDataGroup.selectAll('.node')
                        .attr('transform', d => `translate(${newX(d.xValue)},${newY(d.yValue)})`);

                    // Update trendlines
                    scatterPlotDataGroup.selectAll('.trendline')
                        .attr('d', d3.line()
                            .x(d => newX(d.x))
                            .y(d => newY(d.y))
                        );
                }


    
                // Function to switch between modes and render the appropriate chart
                function scatterPlotSwitchMode() {
                    document.querySelectorAll('.scatterPlot-mode-selector button').forEach(btn => btn.classList.remove('active'));
                    this.classList.add('active');
                    scatterPlotCurrentMode = this.id === "scatterPlot-mode1Button" ? "mode1" : "mode2";
    
                    // Remove elements from both modes
                    scatterPlotDataGroup.selectAll(".mode1").remove();
                    scatterPlotDataGroup.selectAll(".mode2").remove();
                    scatterPlotSvg.selectAll(".x-axis.mode1").remove();
                    scatterPlotSvg.selectAll(".y-axis.mode1").remove();
                    scatterPlotSvg.selectAll(".x-axis.mode2").remove();
                    scatterPlotSvg.selectAll(".y-axis.mode2").remove();
                    scatterPlotSvg.selectAll(".x-label.mode1").remove();
                    scatterPlotSvg.selectAll(".y-label.mode1").remove();
                    scatterPlotSvg.selectAll(".x-label.mode2").remove();
                    scatterPlotSvg.selectAll(".y-label.mode2").remove();
                    scatterPlotSvg.selectAll(".no-data-text").remove();
                    d3.select("#scatterPlotLegendContainer").selectAll("*").remove();
    
                    // Reset zoom on mode switch
                    scatterPlotSvgElement.transition()
                        .duration(750)
                        .call(scatterPlotZoom.transform, d3.zoomIdentity);
    
                    // Change title based on mode
                    const chartTitle = document.getElementById("scatterPlotTitle");
                    if (scatterPlotCurrentMode === "mode1") {
                        chartTitle.textContent = "Performance vs Team Spending Over Selected Seasons";
                        document.getElementById("scatterPlot-seasonFilter").style.display = "inline-block";
                        document.getElementById("scatterPlot-teamFilter").style.display = "none";
                        renderScatterPlotMode1();
                    } else {
                        chartTitle.textContent = "Performance and Total Transfer Spending Per Team Over the Seasons";
                        document.getElementById("scatterPlot-seasonFilter").style.display = "none";
                        document.getElementById("scatterPlot-teamFilter").style.display = "inline-block";
                        renderScatterPlotMode2();
                    }
                }
    
                // Event listeners for mode buttons
                const scatterPlotMode1Button = document.getElementById("scatterPlot-mode1Button");
                const scatterPlotMode2Button = document.getElementById("scatterPlot-mode2Button");
                if (scatterPlotMode1Button && scatterPlotMode2Button) {
                    scatterPlotMode1Button.addEventListener("click", scatterPlotSwitchMode);
                    scatterPlotMode2Button.addEventListener("click", scatterPlotSwitchMode);
                }

                // Initial rendering
                if (scatterPlotMode1Button) {
                    scatterPlotSwitchMode.call(scatterPlotMode1Button);
                }

            }).catch(error => {
                console.error("Error loading data:", error);
            });
        })();
    </script>

</body>
</html>